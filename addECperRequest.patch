diff --git a/Amazon.Extensions.S3.Encryption.sln b/Amazon.Extensions.S3.Encryption.sln
index 18dc253..5f9cfef 100644
--- a/Amazon.Extensions.S3.Encryption.sln
+++ b/Amazon.Extensions.S3.Encryption.sln
@@ -13,6 +13,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Amazon.Extensions.S3.Encryp
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Amazon.Extensions.S3.Encryption.IntegrationTests.NetStandard", "test\IntegrationTests\Amazon.Extensions.S3.Encryption.IntegrationTests.NetStandard.csproj", "{C0B82829-DC7B-4571-92CA-2B8CB695C65A}"
 EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Amazon.Extensions.S3.Encryption.Tests.Common", "test\Common\Amazon.Extensions.S3.Encryption.Tests.Common.csproj", "{E2102F29-07C0-469B-A6D8-2C520B8FDF8C}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -35,6 +37,10 @@ Global
 		{C0B82829-DC7B-4571-92CA-2B8CB695C65A}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{C0B82829-DC7B-4571-92CA-2B8CB695C65A}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{C0B82829-DC7B-4571-92CA-2B8CB695C65A}.Release|Any CPU.Build.0 = Release|Any CPU
+		{E2102F29-07C0-469B-A6D8-2C520B8FDF8C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{E2102F29-07C0-469B-A6D8-2C520B8FDF8C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{E2102F29-07C0-469B-A6D8-2C520B8FDF8C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{E2102F29-07C0-469B-A6D8-2C520B8FDF8C}.Release|Any CPU.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/src/Amazon.Extensions.S3.Encryption.csproj b/src/Amazon.Extensions.S3.Encryption.csproj
index 177c6ff..4a63c11 100644
--- a/src/Amazon.Extensions.S3.Encryption.csproj
+++ b/src/Amazon.Extensions.S3.Encryption.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
     <PropertyGroup>
         <TargetFrameworks>net472;netstandard2.0;netcoreapp3.1;net8.0</TargetFrameworks>
@@ -48,6 +48,12 @@
         <PackageReference Include="Microsoft.SourceLink.GitHub" Version="8.0.0" PrivateAssets="All" />
     </ItemGroup>
 
+    <ItemGroup>
+        <AssemblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleTo">
+            <_Parameter1>Amazon.Extensions.S3.Encryption.UnitTests,PublicKey=0024000004800000940000000602000000240000525341310004000001000100db5f59f098d27276c7833875a6263a3cc74ab17ba9a9df0b52aedbe7252745db7274d5271fd79c1f08f668ecfa8eaab5626fa76adc811d3c8fc55859b0d09d3bc0a84eecd0ba891f2b8a2fc55141cdcc37c2053d53491e650a479967c3622762977900eddbf1252ed08a2413f00a28f3a0752a81203f03ccb7f684db373518b4</_Parameter1>
+        </AssemblyAttribute>
+    </ItemGroup>
+
     <!-- TODO: The dependency on Microsoft.Bcl.AsyncInterfaces should be removed once the issue causing it to be needed in the .NET SDK is fixed  -->
     <ItemGroup Condition="'$(TargetFramework)' == 'net472' Or '$(TargetFramework)' == 'netstandard2.0'">
         <PackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="8.0.0" />
diff --git a/src/AmazonS3EncryptionClientException.cs b/src/AmazonS3EncryptionClientException.cs
new file mode 100644
index 0000000..d2b7dbe
--- /dev/null
+++ b/src/AmazonS3EncryptionClientException.cs
@@ -0,0 +1,32 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+using System;
+
+namespace Amazon.Extensions.S3.Encryption
+{
+    /// <summary>
+    /// Exception thrown by the S3EC for errors that occur within S3EC that are generic enough to be classified.
+    /// </summary>
+#if !PCL && NETFRAMEWORK
+    [Serializable]
+#endif
+    public class AmazonS3EncryptionClientException: Exception
+    {
+        public AmazonS3EncryptionClientException(string message) : base(message) { }
+
+        public AmazonS3EncryptionClientException(string message, Exception innerException) : base(message, innerException) { }
+    }
+}
\ No newline at end of file
diff --git a/src/EncryptionMaterialsV2.cs b/src/EncryptionMaterialsV2.cs
index 641e8b6..673fae2 100644
--- a/src/EncryptionMaterialsV2.cs
+++ b/src/EncryptionMaterialsV2.cs
@@ -19,6 +19,7 @@ using System.Linq;
 using System.Security.Cryptography;
 using System.Text;
 using Amazon.Extensions.S3.Encryption.Primitives;
+using Amazon.Extensions.S3.Encryption.Util;
 
 namespace Amazon.Extensions.S3.Encryption
 {
@@ -43,6 +44,13 @@ namespace Amazon.Extensions.S3.Encryption
         /// Type of the KMS Id
         /// </summary>
         internal KmsType KmsType { get; }
+        
+        /// <summary>
+        /// This is the default material description if user provides nothing
+        /// This contains the reserved keys in Encryption Materials V2
+        /// </summary>
+        internal static readonly Dictionary<string, string> DefaultMaterialsDescription = 
+            new Dictionary<string, string> { [EncryptionUtils.XAmzEncryptionContextCekAlg] = EncryptionUtils.XAmzAesGcmCekAlgValue };
 
         /// <summary>
         /// Constructs a new EncryptionMaterials object, storing an asymmetric key.
@@ -73,19 +81,21 @@ namespace Amazon.Extensions.S3.Encryption
         public EncryptionMaterialsV2(string kmsKeyId, KmsType kmsType, Dictionary<string, string> materialsDescription)
             : base(null, null, kmsKeyId, materialsDescription)
         {
-            if (materialsDescription == null)
-            {
-                throw new ArgumentNullException(nameof(materialsDescription));
-            }
-
-            if (materialsDescription.ContainsKey(EncryptionUtils.XAmzEncryptionContextCekAlg))
-            {
-                throw new ArgumentException($"Conflict in reserved KMS Encryption Context key {EncryptionUtils.XAmzEncryptionContextCekAlg}. " +
-                                            $"This value is reserved for the S3 Encryption Client and cannot be set by the user.");
-            }
-
+            EncryptionContextUtils.ValidateECFromUserInput(materialsDescription);
+                
             materialsDescription[EncryptionUtils.XAmzEncryptionContextCekAlg] = EncryptionUtils.XAmzAesGcmCekAlgValue;
             KmsType = kmsType;
         }
+
+        /// <summary>
+        /// Constructs a new EncryptionMaterials object, storing a KMS Key ID
+        /// </summary>
+        /// <param name="kmsKeyId">Generic KMS Id</param>
+        /// <param name="kmsType">Type of the KMS Id</param>
+        public EncryptionMaterialsV2(string kmsKeyId, KmsType kmsType)
+            : base(null, null, kmsKeyId, DefaultMaterialsDescription)
+        {
+            KmsType = kmsType;
+        }
     }
 }
diff --git a/src/EncryptionUtilsV2.cs b/src/EncryptionUtilsV2.cs
index b973e34..3c2a96a 100644
--- a/src/EncryptionUtilsV2.cs
+++ b/src/EncryptionUtilsV2.cs
@@ -24,6 +24,7 @@ using Amazon.Extensions.S3.Encryption.Util;
 using Amazon.KeyManagementService;
 using Amazon.KeyManagementService.Model;
 using Amazon.Runtime;
+using Amazon.Runtime.Internal;
 using Amazon.S3.Model;
 
 namespace Amazon.Extensions.S3.Encryption
@@ -113,7 +114,7 @@ namespace Amazon.Extensions.S3.Encryption
         /// The instruction that will be used to encrypt the object data.
         /// </param>
         /// <returns>
-        /// Encrypted stream, i.e input stream wrapped into encrypted stream
+        /// Encrypted stream, i.e. input stream wrapped into encrypted stream
         /// </returns>
         internal static Stream EncryptRequestUsingInstructionV2(Stream toBeEncrypted, EncryptionInstructions instructions)
         {
@@ -330,7 +331,7 @@ namespace Amazon.Extensions.S3.Encryption
         /// The instruction that will be used to encrypt the object data.
         /// </param>
         /// <returns>
-        /// Encrypted stream, i.e input stream wrapped into encrypted stream
+        /// Encrypted stream, i.e. input stream wrapped into encrypted stream
         /// </returns>
         internal static Stream EncryptUploadPartRequestUsingInstructionsV2(Stream toBeEncrypted, EncryptionInstructions instructions)
         {
@@ -353,7 +354,7 @@ namespace Amazon.Extensions.S3.Encryption
         /// <returns>
         /// The instruction that will be used to encrypt an object.
         /// </returns>
-        internal static EncryptionInstructions GenerateInstructionsForKMSMaterialsV2(IAmazonKeyManagementService kmsClient, EncryptionMaterialsV2 materials)
+        internal static EncryptionInstructions GenerateInstructionsForKMSMaterialsV2(IAmazonKeyManagementService kmsClient, EncryptionMaterialsV2 materials, Dictionary<string, string> encryptionContext)
         {
             if (materials.KMSKeyID == null)
             {
@@ -371,11 +372,11 @@ namespace Amazon.Extensions.S3.Encryption
                     var result = kmsClient.GenerateDataKey(new GenerateDataKeyRequest
                     {
                         KeyId = materials.KMSKeyID,
-                        EncryptionContext = materials.MaterialsDescription,
+                        EncryptionContext = encryptionContext,
                         KeySpec = KMSKeySpec
                     });
 
-                    var instructions = new EncryptionInstructions(materials.MaterialsDescription, result.Plaintext.ToArray(), result.CiphertextBlob.ToArray(), nonce,
+                    var instructions = new EncryptionInstructions(encryptionContext, result.Plaintext.ToArray(), result.CiphertextBlob.ToArray(), nonce,
                         XAmzWrapAlgKmsContextValue, XAmzAesGcmCekAlgValue);
                     return instructions;
                 }
@@ -399,7 +400,7 @@ namespace Amazon.Extensions.S3.Encryption
         /// The instruction that will be used to encrypt an object.
         /// </returns>
         internal static async System.Threading.Tasks.Task<EncryptionInstructions> GenerateInstructionsForKMSMaterialsV2Async(IAmazonKeyManagementService kmsClient,
-            EncryptionMaterialsV2 materials)
+            EncryptionMaterialsV2 materials, Dictionary<string, string> encryptionContext)
         {
             if (materials.KMSKeyID == null)
             {
@@ -417,11 +418,11 @@ namespace Amazon.Extensions.S3.Encryption
                     var result = await kmsClient.GenerateDataKeyAsync(new GenerateDataKeyRequest
                     {
                         KeyId = materials.KMSKeyID,
-                        EncryptionContext = materials.MaterialsDescription,
+                        EncryptionContext = encryptionContext,
                         KeySpec = KMSKeySpec
                     }).ConfigureAwait(false);
 
-                    var instructions = new EncryptionInstructions(materials.MaterialsDescription, result.Plaintext.ToArray(), result.CiphertextBlob.ToArray(), nonce,
+                    var instructions = new EncryptionInstructions(encryptionContext, result.Plaintext.ToArray(), result.CiphertextBlob.ToArray(), nonce,
                         XAmzWrapAlgKmsContextValue, XAmzAesGcmCekAlgValue);
                     return instructions;
                 }
diff --git a/src/Extensions/S3RequestExtensions.cs b/src/Extensions/S3RequestExtensions.cs
new file mode 100644
index 0000000..a40eb1c
--- /dev/null
+++ b/src/Extensions/S3RequestExtensions.cs
@@ -0,0 +1,45 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+using System.Collections.Generic;
+using Amazon.Extensions.S3.Encryption.Util;
+using Amazon.Runtime.Internal;
+using Amazon.S3.Model;
+
+namespace Amazon.Extensions.S3.Encryption.Extensions
+{
+    public static class S3RequestExtensions
+    {
+        public static void SetEncryptionContext(this PutObjectRequest request, Dictionary<string,string> encryptionContext)
+        {
+            SetEncryptionContextInternal(request, encryptionContext);
+        }
+
+        public static void SetEncryptionContext(this GetObjectRequest request, Dictionary<string,string> encryptionContext)
+        {
+            SetEncryptionContextInternal(request, encryptionContext);
+        }
+        
+        public static void SetEncryptionContext(this InitiateMultipartUploadRequest request, Dictionary<string,string> encryptionContext)
+        {                                                                                                                                                                                                                
+            SetEncryptionContextInternal(request, encryptionContext);                                                                                                                                                    
+        } 
+        
+        private static void SetEncryptionContextInternal(IAmazonWebServiceRequest request, Dictionary<string,string> encryptionContext)
+        {
+            request.RequestState[Constants.S3ECPerRequestEncryptionContext] = encryptionContext;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Internal/SetupDecryptionHandler.cs b/src/Internal/SetupDecryptionHandler.cs
index 0f69c97..8998f29 100644
--- a/src/Internal/SetupDecryptionHandler.cs
+++ b/src/Internal/SetupDecryptionHandler.cs
@@ -54,19 +54,24 @@ namespace Amazon.Extensions.S3.Encryption.Internal
             using (TelemetryUtilities.CreateSpan(EncryptionClient, Constants.SetupDecryptionHandlerSpanName, null, Amazon.Runtime.Telemetry.Tracing.SpanKind.CLIENT))
             {
                 byte[] encryptedKMSEnvelopeKey;
-                Dictionary<string, string> encryptionContext;
+                Dictionary<string, string> encryptionContextFromMetaData;
                 byte[] decryptedEnvelopeKeyKMS = null;
-
-                if (KMSEnvelopeKeyIsPresent(executionContext, out encryptedKMSEnvelopeKey, out encryptionContext))
+                var getObjectResponse = executionContext.ResponseContext.Response as GetObjectResponse;
+                
+                if (getObjectResponse != null && KMSEnvelopeKeyIsPresentOnDecrypt(executionContext, out encryptedKMSEnvelopeKey, out encryptionContextFromMetaData))
                 {
+                    var isEncryptionContextSupported = IsEncryptionContextSupported(getObjectResponse);
+                    var effectiveEncryptionContext = ValidateAndGetEffectiveEncryptionContext(executionContext, encryptionContextFromMetaData, isEncryptionContextSupported);
 #if NETFRAMEWORK
-                    decryptedEnvelopeKeyKMS = DecryptedEnvelopeKeyKms(encryptedKMSEnvelopeKey, encryptionContext);
+                    decryptedEnvelopeKeyKMS = DecryptedEnvelopeKeyKms(encryptedKMSEnvelopeKey, effectiveEncryptionContext);
 #else
-                    decryptedEnvelopeKeyKMS = DecryptedEnvelopeKeyKmsAsync(encryptedKMSEnvelopeKey, encryptionContext).GetAwaiter().GetResult();
+                    decryptedEnvelopeKeyKMS = DecryptedEnvelopeKeyKmsAsync(encryptedKMSEnvelopeKey, effectiveEncryptionContext).GetAwaiter().GetResult();
 #endif
+                } 
+                else if (getObjectResponse != null) {
+                    EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(executionContext);
                 }
-
-                var getObjectResponse = executionContext.ResponseContext.Response as GetObjectResponse;
+                
                 if (getObjectResponse != null)
                 {
 #if NETFRAMEWORK
@@ -133,15 +138,19 @@ namespace Amazon.Extensions.S3.Encryption.Internal
             using (TelemetryUtilities.CreateSpan(EncryptionClient, Constants.SetupDecryptionHandlerSpanName, null, Amazon.Runtime.Telemetry.Tracing.SpanKind.CLIENT))
             {
                 byte[] encryptedKMSEnvelopeKey;
-                Dictionary<string, string> encryptionContext;
+                Dictionary<string, string> encryptionContextFromMetaData;
                 byte[] decryptedEnvelopeKeyKMS = null;
-
-                if (KMSEnvelopeKeyIsPresent(executionContext, out encryptedKMSEnvelopeKey, out encryptionContext))
+                var getObjectResponse = executionContext.ResponseContext.Response as GetObjectResponse;
+                if (getObjectResponse != null && KMSEnvelopeKeyIsPresentOnDecrypt(executionContext, out encryptedKMSEnvelopeKey, out encryptionContextFromMetaData))
                 {
-                    decryptedEnvelopeKeyKMS = await DecryptedEnvelopeKeyKmsAsync(encryptedKMSEnvelopeKey, encryptionContext).ConfigureAwait(false);
+                    var isEncryptionContextSupported = IsEncryptionContextSupported(getObjectResponse);
+                    var effectiveEncryptionContext = ValidateAndGetEffectiveEncryptionContext(executionContext, encryptionContextFromMetaData, isEncryptionContextSupported);
+                    decryptedEnvelopeKeyKMS = await DecryptedEnvelopeKeyKmsAsync(encryptedKMSEnvelopeKey, effectiveEncryptionContext).ConfigureAwait(false);
+                } 
+                else if (getObjectResponse != null) {
+                    EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(executionContext);
                 }
-
-                var getObjectResponse = executionContext.ResponseContext.Response as GetObjectResponse;
+                
                 if (getObjectResponse != null)
                 {
                     await DecryptObjectAsync(decryptedEnvelopeKeyKMS, getObjectResponse).ConfigureAwait(false);
@@ -230,20 +239,21 @@ namespace Amazon.Extensions.S3.Encryption.Internal
         }
 
         /// <summary>
-        /// Verify whether envelope is KMS or not
+        /// Verify whether envelope is KMS or not on decrypt path only
         /// Populate envelope key and encryption context
+        /// Returns false if not on decrypt path
         /// </summary>
         /// <param name="executionContext">The execution context, it contains the request and response context.</param>
         /// <param name="encryptedKMSEnvelopeKey">Encrypted KMS envelope key</param>
-        /// <param name="encryptionContext">KMS encryption context used for encryption and decryption</param>
+        /// <param name="encryptionContextFromMetaData">KMS encryption context stored in MetaData that could be used for decryption</param>
         /// <returns></returns>
-        protected bool KMSEnvelopeKeyIsPresent(IExecutionContext executionContext,
-            out byte[] encryptedKMSEnvelopeKey, out Dictionary<string, string> encryptionContext)
+        protected bool KMSEnvelopeKeyIsPresentOnDecrypt(IExecutionContext executionContext,
+            out byte[] encryptedKMSEnvelopeKey, out Dictionary<string, string> encryptionContextFromMetaData)
         {
             var response = executionContext.ResponseContext.Response;
             var getObjectResponse = response as GetObjectResponse;
             encryptedKMSEnvelopeKey = null;
-            encryptionContext = null;
+            encryptionContextFromMetaData = null;
 
             if (getObjectResponse != null)
             {
@@ -260,7 +270,7 @@ namespace Amazon.Extensions.S3.Encryption.Internal
                     }
 
                     encryptedKMSEnvelopeKey = Convert.FromBase64String(base64EncodedEncryptedKmsEnvelopeKey);
-                    encryptionContext = EncryptionUtils.GetMaterialDescriptionFromMetaData(metadata);
+                    encryptionContextFromMetaData = EncryptionUtils.GetMaterialDescriptionFromMetaData(metadata);
 
                     return true;
                 }
@@ -486,5 +496,36 @@ namespace Amazon.Extensions.S3.Encryption.Internal
             // It is safe to remove the request as it has been already added to the CurrentMultiPartUploadKeys
             EncryptionClient.AllMultiPartUploadRequestContexts.TryRemove(initiateMultiPartUploadRequest, out _);
         }
+        
+        private bool IsEncryptionContextSupported(GetObjectResponse response)
+        {
+            // Object with encryption context supported will have:
+            //  - "x-amz-wrap-alg" key in Metadata key
+            //  - "x-amz-wrap-alg" key in Metadata key will have value "kms+context"
+            return response.Metadata[EncryptionUtils.XAmzWrapAlg] != null && 
+                   EncryptionUtils.XAmzWrapAlgKmsContextValue.Equals(response.Metadata[EncryptionUtils.XAmzWrapAlg]);                                                                                                                                                                                                                                                                 
+        }
+        
+        private static Dictionary<string, string> ValidateAndGetEffectiveEncryptionContext(
+            IExecutionContext executionContext,                                                                                                                                                                          
+            Dictionary<string, string> encryptionContextFromMetaData,
+            bool isEncryptionContextSupported)
+        {
+            var ecFromRequest = EncryptionContextUtils.GetEncryptionContextFromRequest(executionContext.RequestContext.OriginalRequest);
+            if (ecFromRequest == null) {
+                return encryptionContextFromMetaData;
+            }
+            if (isEncryptionContextSupported) {
+                EncryptionContextUtils.ThrowIfECContainsReservedKeysForV2Client(ecFromRequest);
+                // EC in request will not have reserved field as request is not associated with client
+                // This reserve field is only for object written by S3EC V2 client
+                EncryptionContextUtils.ValidateECFromUserInput(ecFromRequest);
+                ecFromRequest[EncryptionUtils.XAmzEncryptionContextCekAlg] = EncryptionUtils.XAmzAesGcmCekAlgValue;
+            } else {
+              ErrorsUtils.ThrowECNotSupported();  
+            }
+            EncryptionContextUtils.ValidateEncryptionContext(ecFromRequest, encryptionContextFromMetaData);
+            return ecFromRequest;
+        }
     }
 }
diff --git a/src/Internal/SetupDecryptionHandlerV1.cs b/src/Internal/SetupDecryptionHandlerV1.cs
index fa22a39..bcc19e0 100644
--- a/src/Internal/SetupDecryptionHandlerV1.cs
+++ b/src/Internal/SetupDecryptionHandlerV1.cs
@@ -1,4 +1,4 @@
-﻿﻿/*
+﻿/*
  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License").
diff --git a/src/Internal/SetupEncryptionHandlerV1.cs b/src/Internal/SetupEncryptionHandlerV1.cs
index 1831021..59c1e95 100644
--- a/src/Internal/SetupEncryptionHandlerV1.cs
+++ b/src/Internal/SetupEncryptionHandlerV1.cs
@@ -41,6 +41,11 @@ using Amazon.Extensions.S3.Encryption.Util;
         /// <inheritdoc/>
         protected override EncryptionInstructions GenerateInstructions(IExecutionContext executionContext)
         {
+            var request = executionContext.RequestContext.OriginalRequest;
+            if (request is PutObjectRequest || request is InitiateMultipartUploadRequest)
+            {
+                ThrowIfECOnRequest(executionContext);
+            }
             EncryptionInstructions instructions = null;
 
             if (NeedToGenerateKMSInstructions(executionContext))
@@ -60,6 +65,12 @@ using Amazon.Extensions.S3.Encryption.Util;
         /// <inheritdoc/>
         protected override async System.Threading.Tasks.Task<EncryptionInstructions> GenerateInstructionsAsync(IExecutionContext executionContext)
         {
+            var request = executionContext.RequestContext.OriginalRequest;
+            if (request is PutObjectRequest || request is InitiateMultipartUploadRequest)
+            {
+                ThrowIfECOnRequest(executionContext);
+            }
+            
             EncryptionInstructions instructions = null;
             if (NeedToGenerateKMSInstructions(executionContext))
             {
@@ -155,5 +166,14 @@ using Amazon.Extensions.S3.Encryption.Util;
             }
             ((Amazon.Runtime.Internal.IAmazonWebServiceRequest)request).RequestState.Add(Constants.S3CryptoStreamRequestState, request.InputStream);
         }
+
+        private void ThrowIfECOnRequest(IExecutionContext executionContext)
+        {
+            var ecFromRequest = EncryptionContextUtils.GetEncryptionContextFromRequest(executionContext.RequestContext.OriginalRequest);
+            if (ecFromRequest != null)
+            {
+                ErrorsUtils.ThrowECNotSupported();
+            }
+        }
     }
 }
diff --git a/src/Internal/SetupEncryptionHandlerV2.cs b/src/Internal/SetupEncryptionHandlerV2.cs
index eb55e21..a476584 100644
--- a/src/Internal/SetupEncryptionHandlerV2.cs
+++ b/src/Internal/SetupEncryptionHandlerV2.cs
@@ -1,4 +1,4 @@
-﻿﻿/*
+﻿/*
  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License").
@@ -17,6 +17,7 @@ using Amazon.Extensions.S3.Encryption.Util;
 using Amazon.Runtime;
 using Amazon.S3.Model;
 using System;
+using System.Collections.Generic;
 
 namespace Amazon.Extensions.S3.Encryption.Internal
 {
@@ -101,11 +102,13 @@ namespace Amazon.Extensions.S3.Encryption.Internal
             EncryptionInstructions instructions = null;
             if (NeedToGenerateKMSInstructions(executionContext))
             {
-                instructions = EncryptionUtils.GenerateInstructionsForKMSMaterialsV2(EncryptionClient.KMSClient, EncryptionMaterials);
+                var effectiveEncryptionContext = ValidateAndGetEffectiveEncryptionContext(executionContext, EncryptionMaterials.MaterialsDescription);
+                instructions = EncryptionUtils.GenerateInstructionsForKMSMaterialsV2(EncryptionClient.KMSClient, EncryptionMaterials, effectiveEncryptionContext);
             }
 
             if (instructions == null && NeedToGenerateInstructions(executionContext))
             {
+                EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(executionContext);
                 instructions = EncryptionUtils.GenerateInstructionsForNonKmsMaterialsV2(EncryptionMaterials);
             }
 
@@ -132,12 +135,14 @@ namespace Amazon.Extensions.S3.Encryption.Internal
             EncryptionInstructions instructions = null;
             if (NeedToGenerateKMSInstructions(executionContext))
             {
-                instructions = await EncryptionUtils.GenerateInstructionsForKMSMaterialsV2Async(EncryptionClient.KMSClient, EncryptionMaterials)
+                var effectiveEncryptionContext = ValidateAndGetEffectiveEncryptionContext(executionContext, EncryptionMaterials.MaterialsDescription);
+                instructions = await EncryptionUtils.GenerateInstructionsForKMSMaterialsV2Async(EncryptionClient.KMSClient, EncryptionMaterials, effectiveEncryptionContext)
                     .ConfigureAwait(false);
             }
 
             if (instructions == null && NeedToGenerateInstructions(executionContext))
             {
+                EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(executionContext);
                 instructions = EncryptionUtils.GenerateInstructionsForNonKmsMaterialsV2(EncryptionMaterials);
             }
 
@@ -238,5 +243,30 @@ namespace Amazon.Extensions.S3.Encryption.Internal
                 aesGcmEncryptStream.DisableDispose = !request.IsLastPart;
             }
         }
+        
+        private static Dictionary<string, string> ValidateAndGetEffectiveEncryptionContext(
+            IExecutionContext executionContext,
+            Dictionary<string, string> encryptionContextInClient)
+        {
+            var ecFromRequest = EncryptionContextUtils.GetEncryptionContextFromRequest(executionContext.RequestContext.OriginalRequest);
+            
+            // encryption context in client will be at least DefaultMaterialsDescription
+            if (ecFromRequest != null && encryptionContextInClient != EncryptionMaterialsV2.DefaultMaterialsDescription)
+            {
+                ErrorsUtils.ThrowMultipleECOnEncryptPath();
+            }
+            if (ecFromRequest != null)
+            {
+                EncryptionContextUtils.ThrowIfECContainsReservedKeysForV2Client(ecFromRequest);
+                // EC in request will not have reserved field as request is not associated with client
+                // This reserve field is only for object written by S3EC V2 client
+                ecFromRequest[EncryptionUtils.XAmzEncryptionContextCekAlg] = EncryptionUtils.XAmzAesGcmCekAlgValue;
+                return ecFromRequest;
+            }
+            
+            // Client already has reserved field added because while adding EC on client
+            // we know the version of the S3EC client
+            return encryptionContextInClient; 
+        }
     }
 }
diff --git a/src/Util/Constants.cs b/src/Util/Constants.cs
index e3c5fa8..814677d 100644
--- a/src/Util/Constants.cs
+++ b/src/Util/Constants.cs
@@ -17,7 +17,7 @@ namespace Amazon.Extensions.S3.Encryption.Util
     internal class Constants
     {
         internal const string S3CryptoStreamRequestState = "S3-Crypto-Stream";
-
+        internal const string S3ECPerRequestEncryptionContext = "S3EC-Encryption-Context";
 
         internal const string S3TransferTracerScope = "S3.Encryption";
         internal const string SetupEncryptionHandlerSpanName = "EncryptionHandler";
diff --git a/src/Util/EncryptionContextUtils.cs b/src/Util/EncryptionContextUtils.cs
new file mode 100644
index 0000000..146ad9b
--- /dev/null
+++ b/src/Util/EncryptionContextUtils.cs
@@ -0,0 +1,76 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+using System;
+using System.Collections.Generic;
+using Amazon.Runtime;
+using Amazon.Runtime.Internal;
+
+namespace Amazon.Extensions.S3.Encryption.Util
+{
+    internal class EncryptionContextUtils
+    {
+        internal static void ValidateECFromUserInput(Dictionary<string, string> encryptionContext)
+        {
+            if (encryptionContext == null)
+            {
+                throw new ArgumentNullException(nameof(encryptionContext));
+            }
+            if (encryptionContext.ContainsKey(EncryptionUtils.XAmzEncryptionContextCekAlg))
+            {
+                ErrorsUtils.ThrowECContainsReservedKeyV2();
+            }
+        }
+        
+        internal static void ThrowIfECContainsReservedKeysForV2Client(Dictionary<string, string> encryptionContext)
+        {
+            if (encryptionContext.ContainsKey(EncryptionUtils.XAmzEncryptionContextCekAlg))
+            {
+                ErrorsUtils.ThrowECContainsReservedKeyV2();
+            }
+        }
+        
+        internal static void ValidateNoEncryptionContextForNonKMS(IExecutionContext executionContext)
+        {
+            var ecFromRequest = GetEncryptionContextFromRequest(executionContext.RequestContext.OriginalRequest);
+            if (ecFromRequest != null)
+            {
+                ErrorsUtils.ThrowECNotSupported();
+            }
+        }
+        
+        internal static Dictionary<string, string> GetEncryptionContextFromRequest(IAmazonWebServiceRequest internalRequest)
+        {
+            if (internalRequest.RequestState.TryGetValue(Constants.S3ECPerRequestEncryptionContext, out var ec) && ec != null)                                                                                                     
+            {                                                                         
+                // Return a copy to prevent from modifying the original RequestState dictionary
+                return new Dictionary<string, string>((Dictionary<string, string>)ec);
+            }
+            return null;
+        }
+
+        internal static void ValidateEncryptionContext(Dictionary<string, string> effectiveEC, Dictionary<string, string> ecFromMetaData)
+        {
+            if (effectiveEC.Count != ecFromMetaData.Count) 
+                ErrorsUtils.ThrowECMissMatchedException();
+            
+            foreach (var kvp in effectiveEC)
+            {
+                if (!ecFromMetaData.TryGetValue(kvp.Key, out var value) || value != kvp.Value)
+                    ErrorsUtils.ThrowECMissMatchedException();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Util/ErrorsUtils.cs b/src/Util/ErrorsUtils.cs
new file mode 100644
index 0000000..295b9d4
--- /dev/null
+++ b/src/Util/ErrorsUtils.cs
@@ -0,0 +1,61 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+using System;
+
+namespace Amazon.Extensions.S3.Encryption.Util
+{
+    public static class ErrorsUtils
+    {
+        private const string ECMissMatchedException =
+            "Provided encryption context does not match information retrieved from S3";
+
+        private const string ECNotSupported =
+            "Encryption context is only supported for KMS encryption material from V2.";
+
+        private const string ECContainsReservedKeyV2 =
+            "Conflict in reserved KMS Encryption Context key " + EncryptionUtils.XAmzEncryptionContextCekAlg + ". " +
+            "This value is reserved for the S3 Encryption Client and cannot be set by the user.";
+        
+        private const string MultipleECOnEncryptPath =
+            "Encryption context should be set on either client or request.";
+        
+        // Encryption Context is not supported with non KMS material.
+        // This exception is thrown when EC is passed when using non KMS material. 
+        internal static void ThrowECNotSupported()
+        {
+            throw new ArgumentException(ECNotSupported);
+        }
+        
+        // Encryption Context is validated client side with the object's metadata before passing to KMS.
+        // This exception is thrown when EC validation in client side is failed.
+        internal static void ThrowECMissMatchedException()
+        {
+            throw new AmazonS3EncryptionClientException(ECMissMatchedException);
+        }
+        
+        // Encryption Context in V2 Materials contains a reserved key `EncryptionUtils.XAmzEncryptionContextCekAlg`.
+        // This exception is thrown when user includes reserved key in the EC.
+        internal static void ThrowECContainsReservedKeyV2()
+        {
+            throw new ArgumentException(ECContainsReservedKeyV2);
+        }
+
+        internal static void ThrowMultipleECOnEncryptPath()
+        {
+            throw new ArgumentException(MultipleECOnEncryptPath);
+        }
+    }
+}
\ No newline at end of file
diff --git a/test/Common/Amazon.Extensions.S3.Encryption.Tests.Common.csproj b/test/Common/Amazon.Extensions.S3.Encryption.Tests.Common.csproj
new file mode 100644
index 0000000..3a9944e
--- /dev/null
+++ b/test/Common/Amazon.Extensions.S3.Encryption.Tests.Common.csproj
@@ -0,0 +1,19 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+    <PropertyGroup>
+        <TargetFrameworks>net472;net8</TargetFrameworks>
+        <IsPackable>false</IsPackable>
+        <SignAssembly>true</SignAssembly>
+        <AssemblyOriginatorKeyFile>..\..\public.snk</AssemblyOriginatorKeyFile>
+    </PropertyGroup>
+
+    <ItemGroup>
+        <Compile Remove="**/obj/**" />
+        <None Remove="**/obj/**" />
+    </ItemGroup>
+
+    <ItemGroup>
+        <ProjectReference Include="..\..\src\Amazon.Extensions.S3.Encryption.csproj" />
+        <PackageReference Condition="'$(TargetFramework)' == 'net472'" Include="xunit.extensions" Version="1.9.2" />
+        <PackageReference Condition="'$(TargetFramework)' == 'net8'" Include="xunit" Version="2.4.1" />
+    </ItemGroup>
+</Project>
diff --git a/test/Common/CommonUtils.cs b/test/Common/CommonUtils.cs
new file mode 100644
index 0000000..567a65d
--- /dev/null
+++ b/test/Common/CommonUtils.cs
@@ -0,0 +1,82 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Text.Json;
+using System.Threading.Tasks;
+using Amazon.Extensions.S3.Encryption.Extensions;
+using Amazon.KeyManagementService;
+using Amazon.KeyManagementService.Model;
+using Amazon.S3;
+using Amazon.S3.Model;
+using Xunit;
+
+namespace Amazon.Extensions.S3.Encryption.Tests.Common
+{
+    public static class CommonUtils
+    {
+        public static void ValidateMaterialDescription(GetObjectResponse response, Dictionary<string, string> expectedMatDesc)
+        {                                                                                                                                                                                                                                                                                                                                                                                  
+            Assert.NotNull(response.Metadata[TestConstants.XAmzMatDesc]);                                                                                                                                                                                                                                                                                                                   
+            string matDesc = response.Metadata[TestConstants.XAmzMatDesc];                                                                                                                                                                                                                                                                                                                           
+            var actualMatDesc = JsonSerializer.Deserialize<Dictionary<string, string>>(matDesc);                                                                                                                                                                                                                                                                                           
+                                                                                                                                                                                                                                                                                                                                                                                           
+            Assert.Equal(expectedMatDesc.Count, actualMatDesc.Count);                                                                                                                                                                                                                                                                                                                      
+                                                                                                                                                                                                                                                                                                                                                                                           
+            foreach (var kvp in expectedMatDesc)                                                                                                                                                                                                                                                                                                                                           
+            {                                                                                                                                                                                                                                                                                                                                                                              
+                Assert.True(actualMatDesc.ContainsKey(kvp.Key));                                                                                                                                                                                                                                                                                                                           
+                Assert.Equal(kvp.Value, actualMatDesc[kvp.Key]);                                                                                                                                                                                                                                                                                                     
+            }
+        }
+        
+        public static async Task DecryptDataKeyWithoutS3ECAsync(string key, AmazonS3Client s3Client, string bucketName,
+            string encryptionDataKeyLocation, Dictionary<string, string> ECToKMS = null, Dictionary<string, string> requestEC = null)
+        {
+            var getObjectResponse = await CommonUtils.MakeGetObjectAsyncCall(s3Client, bucketName, key, requestEC);
+            
+            var kmsClient = new AmazonKeyManagementServiceClient();
+            var encryptedKey = getObjectResponse.Metadata[encryptionDataKeyLocation];
+            var decryptRequest = new DecryptRequest
+            {
+                CiphertextBlob = new MemoryStream(Convert.FromBase64String(encryptedKey)),
+                EncryptionContext = ECToKMS
+            };
+            
+            // Decrypt will fail ECToKMS is incorrect
+            await kmsClient.DecryptAsync(decryptRequest);
+        }
+        
+        public static async Task<GetObjectResponse> MakeGetObjectAsyncCall(AmazonS3Client s3Client, string bucketName, string key, 
+            Dictionary<string, string> requestEC = null)
+        {
+            GetObjectRequest getObjectRequest = new GetObjectRequest
+            {
+                BucketName = bucketName,
+                Key = key
+            };
+            if (requestEC != null)
+            {
+                getObjectRequest.SetEncryptionContext(requestEC);
+            }
+            
+            var getObjectResponse = await s3Client.GetObjectAsync(getObjectRequest).ConfigureAwait(false);
+            
+            return getObjectResponse;
+        }
+    }
+}
\ No newline at end of file
diff --git a/test/Common/TestConstants.cs b/test/Common/TestConstants.cs
new file mode 100644
index 0000000..8cfc226
--- /dev/null
+++ b/test/Common/TestConstants.cs
@@ -0,0 +1,57 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+using System.Collections.Generic;
+
+namespace Amazon.Extensions.S3.Encryption.Tests.Common
+{
+    public static class TestConstants
+    {
+        public static readonly string RequestEC1Key = "request1";
+        public static readonly string RequestEC2Key = "request2";
+        public static readonly string FallbackECKey = "fallback";
+        public static readonly string RequestEC1Value = "requestValue1";
+        public static readonly string RequestEC2Value = "requestValue2";
+        public static readonly string FallbackECValue = "fallbackValue";
+        public static readonly string XAmzEncryptionContextCekAlg = "aws:x-amz-cek-alg";
+        public static readonly string XAmzAesCbcPaddingCekAlgValue = "AES/CBC/PKCS5Padding";
+        public static readonly string XAmzAesGcmCekAlgValue = "AES/GCM/NoPadding";
+        public static readonly string XAmzMatDesc = "x-amz-matdesc";
+        public static readonly string XAmzKeyV2 = "x-amz-key-v2";
+        public static readonly string ECNotSupported =
+            "Encryption context is only supported for KMS encryption material from V2.";
+
+        public static readonly string ECNotMatched =
+            "Provided encryption context does not match information retrieved from S3";
+
+        public static readonly string ReservedKeyInECErrorMessage =
+            $"Conflict in reserved KMS Encryption Context key {XAmzEncryptionContextCekAlg}. " +
+            "This value is reserved for the S3 Encryption Client and cannot be set by the user.";
+
+        public static readonly string MultipleECErrorMesage =
+            "Encryption context should be set on either client or request.";
+        public static readonly Dictionary<string, string> RequestEC1 = 
+            new Dictionary<string, string> { { RequestEC1Key, RequestEC1Value } };
+        public static readonly Dictionary<string, string> RequestEC2 = 
+            new Dictionary<string, string> { { RequestEC2Key, RequestEC2Value } };
+        public static readonly Dictionary<string, string> FallbackEC = 
+            new Dictionary<string, string> { { FallbackECKey, FallbackECValue } };
+        
+        public static Dictionary<string, string> EncryptionContextWithReservedKey = new Dictionary<string, string>
+        {
+            { XAmzEncryptionContextCekAlg, RequestEC1Value }
+        };
+    }
+}
diff --git a/test/IntegrationTests/Amazon.Extensions.S3.Encryption.IntegrationTests.NetFramework.csproj b/test/IntegrationTests/Amazon.Extensions.S3.Encryption.IntegrationTests.NetFramework.csproj
index a2089b9..2afe190 100644
--- a/test/IntegrationTests/Amazon.Extensions.S3.Encryption.IntegrationTests.NetFramework.csproj
+++ b/test/IntegrationTests/Amazon.Extensions.S3.Encryption.IntegrationTests.NetFramework.csproj
@@ -21,5 +21,6 @@
 
     <ItemGroup>
         <ProjectReference Include="..\..\src\Amazon.Extensions.S3.Encryption.csproj" />
+        <ProjectReference Include="..\Common\Amazon.Extensions.S3.Encryption.Tests.Common.csproj" />
     </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/test/IntegrationTests/_bcl/EncryptionTestsV1NInteropV2.cs b/test/IntegrationTests/_bcl/EncryptionTestsV1NInteropV2.cs
index 2a51808..cf09f99 100644
--- a/test/IntegrationTests/_bcl/EncryptionTestsV1NInteropV2.cs
+++ b/test/IntegrationTests/_bcl/EncryptionTestsV1NInteropV2.cs
@@ -13,12 +13,14 @@
  * permissions and limitations under the License.
  */
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 using System.Security.Cryptography;
 using System.Text;
 using Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities;
 using Amazon.Extensions.S3.Encryption.Primitives;
+using Amazon.Extensions.S3.Encryption.Tests.Common;
 using Amazon.Runtime;
 using Amazon.S3;
 using Amazon.S3.Util;
@@ -67,8 +69,9 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         private static AmazonS3EncryptionClientV2 s3EncryptionClientFileModeAsymmetricWrapV2;
         private static AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeSymmetricWrapV2;
         private static AmazonS3EncryptionClientV2 s3EncryptionClientFileModeSymmetricWrapV2;
-        private static AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSV2;
-        private static AmazonS3EncryptionClientV2 s3EncryptionClientFileModeKMSV2;
+        private static AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSV2WithEC;
+        private static AmazonS3EncryptionClientV2 s3EncryptionClientFileModeKMSV2WithEC;
+        private static AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSV2WithoutEC;
 
         public EncryptionTestsV1NInteropV2() : base(KmsKeyIdProvider.Instance)
         {
@@ -87,8 +90,10 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
 
             var asymmetricEncryptionMaterialsV2 = new EncryptionMaterialsV2(rsa, AsymmetricAlgorithmType.RsaOaepSha1);
             var symmetricEncryptionMaterialsV2 = new EncryptionMaterialsV2(aes, SymmetricAlgorithmType.AesGcm);
-            var kmsEncryptionMaterialsV2 =
+            var kmsEncryptionMaterialsV2WithEC =
                 new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext, new Dictionary<string, string>());
+            var kmsEncryptionMaterialsV2WithoutEC =
+                new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext );
 
             fileConfigV2 = new AmazonS3CryptoConfigurationV2(SecurityProfile.V2AndLegacy)
             {
@@ -130,11 +135,14 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             s3EncryptionClientFileModeSymmetricWrapV2 =
                 new AmazonS3EncryptionClientV2(fileConfigV2, symmetricEncryptionMaterialsV2);
 
-            s3EncryptionClientMetadataModeKMSV2 =
-                new AmazonS3EncryptionClientV2(metadataConfigV2, kmsEncryptionMaterialsV2);
+            s3EncryptionClientMetadataModeKMSV2WithEC =
+                new AmazonS3EncryptionClientV2(metadataConfigV2, kmsEncryptionMaterialsV2WithEC);
 
-            s3EncryptionClientFileModeKMSV2 = new AmazonS3EncryptionClientV2(fileConfigV2, kmsEncryptionMaterialsV2);
+            s3EncryptionClientFileModeKMSV2WithEC = new AmazonS3EncryptionClientV2(fileConfigV2, kmsEncryptionMaterialsV2WithEC);
 
+            s3EncryptionClientMetadataModeKMSV2WithoutEC
+                = new AmazonS3EncryptionClientV2(metadataConfigV2, kmsEncryptionMaterialsV2WithoutEC);
+            
             using (var writer = File.CreateText(filePath))
             {
                 writer.Write(SampleContent);
@@ -157,8 +165,9 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             s3EncryptionClientFileModeAsymmetricWrapV2.Dispose();
             s3EncryptionClientMetadataModeSymmetricWrapV2.Dispose();
             s3EncryptionClientFileModeSymmetricWrapV2.Dispose();
-            s3EncryptionClientMetadataModeKMSV2.Dispose();
-            s3EncryptionClientFileModeKMSV2.Dispose();
+            s3EncryptionClientMetadataModeKMSV2WithEC.Dispose();
+            s3EncryptionClientFileModeKMSV2WithEC.Dispose();
+            s3EncryptionClientMetadataModeKMSV2WithoutEC.Dispose();
 
             if (File.Exists(filePath))
             {
@@ -217,7 +226,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             AssertExtensions.ExpectException(
                 () =>
                 {
-                    EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientFileModeKMSV2,
+                    EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientFileModeKMSV2WithEC,
                         s3EncryptionClientFileModeKMSV1N, bucketName);
                 }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV2);
 
@@ -225,7 +234,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
                 () =>
                 {
                     EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientFileModeKMSV1N,
-                        s3EncryptionClientFileModeKMSV2, bucketName);
+                        s3EncryptionClientFileModeKMSV2WithEC, bucketName);
                 }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV1N);
         }
 
@@ -233,11 +242,11 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void TestTransferUtilityS3EncryptionClientMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientMetadataModeKMSV2,
+            EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientMetadataModeKMSV2WithEC,
                 s3EncryptionClientMetadataModeKMSV1N, bucketName);
 
             EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientMetadataModeKMSV1N,
-                s3EncryptionClientMetadataModeKMSV2, bucketName);
+                s3EncryptionClientMetadataModeKMSV2WithEC, bucketName);
         }
 
         [Fact]
@@ -455,13 +464,13 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV2, s3EncryptionClientFileModeKMSV1N,
+                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV2WithEC, s3EncryptionClientFileModeKMSV1N,
                     filePath, null, null, SampleContent, bucketName);
             }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV2);
 
             AssertExtensions.ExpectException(() =>
             {
-                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2,
+                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2WithEC,
                     filePath, null, null, SampleContent, bucketName);
             }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV1N);
         }
@@ -470,10 +479,10 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void PutGetStreamUsingMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N,
                 null, SampleContentBytes, null, SampleContent, bucketName);
 
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                 null, SampleContentBytes, null, SampleContent, bucketName);
         }
 
@@ -483,13 +492,13 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV2, s3EncryptionClientFileModeKMSV1N,
+                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV2WithEC, s3EncryptionClientFileModeKMSV1N,
                     null, SampleContentBytes, null, SampleContent, bucketName);
             }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV2);
 
             AssertExtensions.ExpectException(() =>
             {
-                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2,
+                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2WithEC,
                     null, SampleContentBytes, null, SampleContent, bucketName);
             }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV1N);
         }
@@ -498,10 +507,10 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void PutGetContentUsingMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N,
                 null, null, SampleContent, SampleContent, bucketName);
 
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                 null, null, SampleContent, SampleContent, bucketName);
         }
 
@@ -509,10 +518,10 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void PutGetZeroLengthContentUsingMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N,
                 null, null, "", "", bucketName);
 
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                 null,
                 null, "", "", bucketName);
         }
@@ -521,10 +530,10 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void PutGetNullContentContentUsingMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N,
                 null, null, null, "", bucketName);
 
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                 null, null, null, "", bucketName);
         }
 
@@ -534,16 +543,128 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV2, s3EncryptionClientFileModeKMSV1N,
+                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV2WithEC, s3EncryptionClientFileModeKMSV1N,
                     null, null, SampleContent, SampleContent, bucketName);
             }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV2);
 
             AssertExtensions.ExpectException(() =>
             {
-                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2,
+                EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2WithEC,
                     null, null, SampleContent, SampleContent, bucketName);
             }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV1N);
         }
+        
+        [Fact]
+        [Trait(CategoryAttribute,"S3")]
+        public void PerRequestEncryptionContextOnV1ObjectRejected()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            // V1 Object does not support request level EC.
+            // Fails as we are trying to put V1 object with request EC
+            AssertExtensions.ExpectException(() =>
+            {
+                EncryptionTestsUtils.TestPut(
+                    s3EncryptionClientMetadataModeKMSV1N,
+                    null, null, SampleContent,
+                    bucketName, key, TestConstants.RequestEC1);
+            }, typeof(ArgumentException), TestConstants.ECNotSupported);
+            AssertExtensions.ExpectException( () =>
+            {
+                EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestPutAsync(
+                    s3EncryptionClientMetadataModeKMSV1N,
+                    null, null, SampleContent,
+                    bucketName, key, TestConstants.RequestEC1));
+            }, typeof(ArgumentException), TestConstants.ECNotSupported);
+                
+            EncryptionTestsUtils.TestPut(
+                s3EncryptionClientMetadataModeKMSV1N,
+                null, null, SampleContent,
+                bucketName, key);
+            
+            // Fails as this is trying to get V1 object with request EC
+            AssertExtensions.ExpectException(() =>
+            {
+                EncryptionTestsUtils.TestGet(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV1N, 
+                    bucketName, TestConstants.RequestEC1);
+            }, typeof(ArgumentException), TestConstants.ECNotSupported);
+            AssertExtensions.ExpectException(() =>
+            {
+                EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestGetAsync(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV1N, 
+                    bucketName, TestConstants.RequestEC1));
+            }, typeof(ArgumentException), TestConstants.ECNotSupported);
+            
+            // Fails as this is trying to get V1 object with request EC even in V2AndLegacy
+            AssertExtensions.ExpectException(() =>
+            {
+                EncryptionTestsUtils.TestGet(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV2WithoutEC, 
+                    bucketName, TestConstants.RequestEC1);
+            }, typeof(ArgumentException), TestConstants.ECNotSupported);
+            AssertExtensions.ExpectException(() =>
+            {
+                EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestGetAsync(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV2WithoutEC, 
+                    bucketName, TestConstants.RequestEC1));
+            }, typeof(ArgumentException), TestConstants.ECNotSupported);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute,"S3")]
+        public void V2PutV1GetWithSameRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            EncryptionTestsUtils.TestPut(
+                s3EncryptionClientMetadataModeKMSV2WithoutEC,
+                null, null, SampleContent,
+                bucketName, key, TestConstants.RequestEC1);
+            
+            // Succeeds as this is trying to get v2 object even with v1 client
+            EncryptionTestsUtils.TestGet(
+                key, SampleContent, s3EncryptionClientMetadataModeKMSV1N,
+                bucketName, TestConstants.RequestEC1);
+            
+            EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestPutAsync(
+                s3EncryptionClientMetadataModeKMSV2WithoutEC,
+                null, null, SampleContent,
+                bucketName, key, TestConstants.RequestEC1));
+            
+            EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestGetAsync(
+                key, SampleContent, s3EncryptionClientMetadataModeKMSV1N,
+                bucketName, TestConstants.RequestEC1));
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute,"S3")]
+        public void V2PutV1GetWithDifferentRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            EncryptionTestsUtils.TestPut(
+                s3EncryptionClientMetadataModeKMSV2WithoutEC,
+                null, null, SampleContent,
+                bucketName, key, TestConstants.RequestEC1);
+            AssertExtensions.ExpectException(() =>
+                {
+                EncryptionTestsUtils.TestGet(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV1N, 
+                    bucketName, TestConstants.RequestEC2);
+            }, typeof(AmazonS3EncryptionClientException), TestConstants.ECNotMatched);
+            
+            EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestPutAsync(
+                s3EncryptionClientMetadataModeKMSV2WithoutEC,
+                null, null, SampleContent,
+                bucketName, key, TestConstants.RequestEC1));
+            AssertExtensions.ExpectException(() =>
+            {
+                EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestGetAsync(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV1N, 
+                    bucketName, TestConstants.RequestEC2));
+            }, typeof(AmazonS3EncryptionClientException), TestConstants.ECNotMatched);
+        }
 
         [Fact]
         [Trait(CategoryAttribute, "S3")]
@@ -593,11 +714,17 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void MultipartEncryptionTestMetadataModeKMS()
         {
-            EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMSV2,
+            EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMSV2WithEC,
                 s3EncryptionClientMetadataModeKMSV1N, bucketName);
 
             EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMSV1N,
-                s3EncryptionClientMetadataModeKMSV2, bucketName);
+                s3EncryptionClientMetadataModeKMSV2WithEC, bucketName);
+            
+            EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMSV2WithoutEC,
+                s3EncryptionClientMetadataModeKMSV1N, bucketName, TestConstants.RequestEC1, TestConstants.RequestEC1);
+
+            EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMSV1N,
+                s3EncryptionClientMetadataModeKMSV2WithoutEC, bucketName, TestConstants.RequestEC1, TestConstants.RequestEC1);
         }
 
         [Fact]
@@ -607,7 +734,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             AssertExtensions.ExpectException(
                 () =>
                 {
-                    EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientFileModeKMSV2,
+                    EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientFileModeKMSV2WithEC,
                         s3EncryptionClientFileModeKMSV1N, bucketName);
                 }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV2);
 
@@ -615,7 +742,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
                 () =>
                 {
                     EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientFileModeKMSV1N,
-                        s3EncryptionClientFileModeKMSV2, bucketName);
+                        s3EncryptionClientFileModeKMSV2WithEC, bucketName);
                 }, typeof(AmazonClientException), InstructionAndKMSErrorMessageV1N);
         }
 
@@ -628,7 +755,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             AssertExtensions.ExpectException(() =>
             {
                 EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSV1N,
-                    s3EncryptionClientMetadataModeKMSV2,
+                    s3EncryptionClientMetadataModeKMSV2WithEC,
                     filePath, null, null, SampleContent, bucketName);
             }, typeof(AmazonCryptoException), LegacyReadWhenLegacyDisabledMessage);
         }
diff --git a/test/IntegrationTests/_bcl/EncryptionTestsV2.cs b/test/IntegrationTests/_bcl/EncryptionTestsV2.cs
index 4396576..b03afcf 100644
--- a/test/IntegrationTests/_bcl/EncryptionTestsV2.cs
+++ b/test/IntegrationTests/_bcl/EncryptionTestsV2.cs
@@ -13,12 +13,16 @@
  * permissions and limitations under the License.
  */
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 using System.Security.Cryptography;
 using System.Text;
+using System.Threading.Tasks;
 using Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities;
 using Amazon.Extensions.S3.Encryption.Primitives;
+using Amazon.Extensions.S3.Encryption.Tests.Common;
+using Amazon.KeyManagementService.Model;
 using Amazon.Runtime;
 using Amazon.S3;
 using Amazon.S3.Util;
@@ -47,8 +51,11 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         private static AmazonS3EncryptionClientV2 s3EncryptionClientFileModeSymmetricWrap;
         private static AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeAsymmetricWrap;
         private static AmazonS3EncryptionClientV2 s3EncryptionClientFileModeAsymmetricWrap;
-        private static AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMS;
-        private static AmazonS3EncryptionClientV2 s3EncryptionClientFileModeKMS;
+        private static AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSWithEC;
+        private static AmazonS3EncryptionClientV2 s3EncryptionClientFileModeKMSWithEC;
+        private static AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSWithoutEC;
+        
+        private AmazonS3Client s3Client;
 
         public EncryptionTestsV2() : base(KmsKeyIdProvider.Instance)
         {
@@ -60,8 +67,11 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             var asymmetricEncryptionMaterials = new EncryptionMaterialsV2(rsa, AsymmetricAlgorithmType.RsaOaepSha1);
             var symmetricEncryptionMaterials = new EncryptionMaterialsV2(aes, SymmetricAlgorithmType.AesGcm);
 
-            var kmsEncryptionMaterials =
+            var kmsEncryptionMaterialsWithEC =
                 new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext, new Dictionary<string, string>());
+            
+            var kmsEncryptionMaterialsWithoutEC =
+                new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext);
 
             var fileConfig = new AmazonS3CryptoConfigurationV2(SecurityProfile.V2)
             {
@@ -85,9 +95,11 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             s3EncryptionClientFileModeAsymmetricWrap =
                 new AmazonS3EncryptionClientV2(fileConfig, asymmetricEncryptionMaterials);
 
-            s3EncryptionClientMetadataModeKMS = new AmazonS3EncryptionClientV2(metadataConfig, kmsEncryptionMaterials);
-
-            s3EncryptionClientFileModeKMS = new AmazonS3EncryptionClientV2(fileConfig, kmsEncryptionMaterials);
+            s3EncryptionClientMetadataModeKMSWithEC = new AmazonS3EncryptionClientV2(metadataConfig, kmsEncryptionMaterialsWithEC);
+            s3EncryptionClientMetadataModeKMSWithoutEC = new AmazonS3EncryptionClientV2(metadataConfig, kmsEncryptionMaterialsWithoutEC);
+            s3EncryptionClientFileModeKMSWithEC = new AmazonS3EncryptionClientV2(fileConfig, kmsEncryptionMaterialsWithEC);
+            
+            s3Client = new AmazonS3Client();
 
             using (var writer = File.CreateText(filePath))
             {
@@ -104,8 +116,10 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             s3EncryptionClientFileModeSymmetricWrap.Dispose();
             s3EncryptionClientMetadataModeAsymmetricWrap.Dispose();
             s3EncryptionClientFileModeAsymmetricWrap.Dispose();
-            s3EncryptionClientMetadataModeKMS.Dispose();
-            s3EncryptionClientFileModeKMS.Dispose();
+            s3EncryptionClientMetadataModeKMSWithEC.Dispose();
+            s3EncryptionClientMetadataModeKMSWithoutEC.Dispose();
+            s3EncryptionClientFileModeKMSWithEC.Dispose();
+            s3Client.Dispose();
             if (File.Exists(filePath))
             {
                 File.Delete(filePath);
@@ -145,7 +159,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         public void TestTransferUtilityS3EncryptionClientFileModeKMS()
         {
             AssertExtensions.ExpectException(
-                () => { EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientFileModeKMS, bucketName); },
+                () => { EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientFileModeKMSWithEC, bucketName); },
                 typeof(AmazonClientException), InstructionAndKMSErrorMessage);
         }
 
@@ -153,7 +167,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void TestTransferUtilityS3EncryptionClientMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientMetadataModeKMS, bucketName);
+            EncryptionTestsUtils.TestTransferUtility(s3EncryptionClientMetadataModeKMSWithEC, bucketName);
         }
 
         [Fact]
@@ -168,7 +182,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void TestTransferUtilityS3EncryptionClientMetadataModeKMSCalculateMD5()
         {
-            EncryptionTestsUtils.TestTransferUtilityCalculateMD5(s3EncryptionClientMetadataModeKMS, s3EncryptionClientMetadataModeKMS, bucketName);
+            EncryptionTestsUtils.TestTransferUtilityCalculateMD5(s3EncryptionClientMetadataModeKMSWithEC, s3EncryptionClientMetadataModeKMSWithEC, bucketName);
         }
 
         [Fact]
@@ -299,7 +313,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             AssertExtensions.ExpectException(
                 () =>
                 {
-                    EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMS, filePath, null, null, SampleContent,
+                    EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSWithEC, filePath, null, null, SampleContent,
                         bucketName);
                 }, typeof(AmazonClientException), InstructionAndKMSErrorMessage);
         }
@@ -308,7 +322,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void PutGetStreamUsingMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMS, null, SampleContentBytes, null,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSWithEC, null, SampleContentBytes, null,
                 SampleContent, bucketName);
         }
 
@@ -319,7 +333,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             AssertExtensions.ExpectException(
                 () =>
                 {
-                    EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMS, null, SampleContentBytes, null,
+                    EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSWithEC, null, SampleContentBytes, null,
                         SampleContent, bucketName);
                 }, typeof(AmazonClientException), InstructionAndKMSErrorMessage);
         }
@@ -328,22 +342,219 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void PutGetContentUsingMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMS, null, null, SampleContent, SampleContent,
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSWithEC, null, null, SampleContent, SampleContent,
                 bucketName);
         }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutGetContentUsingKMSWithSameRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            var encryptionContext = new Dictionary<string, string>(TestConstants.RequestEC1);
+            var expectedEncryptionContext = encryptionContext;
+
+            expectedEncryptionContext.Add(TestConstants.XAmzEncryptionContextCekAlg, TestConstants.XAmzAesGcmCekAlgValue);
+            
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
+                SampleContent, SampleContent, bucketName, key, TestConstants.RequestEC1, TestConstants.RequestEC1);
+            
+            // This proves the material description in S3 is what we expect.
+            EncryptionTestsUtils.TestGet(
+                key, SampleContent, s3Client, bucketName,
+                TestConstants.RequestEC1, false, true, expectedEncryptionContext);
+            
+            EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestGetAsync(
+                key, SampleContent, s3Client, bucketName,
+                TestConstants.RequestEC1, false, true, expectedEncryptionContext));
+            
+            // This proves the EC we are sending to KMS is actually the EC we expect without using S3EC at all.
+            EncryptionTestsUtils.DecryptDataKeyWithoutS3EC(key, s3Client, bucketName,
+                TestConstants.XAmzKeyV2, expectedEncryptionContext, TestConstants.RequestEC1);
+            
+            // This is expected to fail as TestConstants.RequestEC1 does not have reserved key and mismatch is expected.
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.DecryptDataKeyWithoutS3EC(key, s3Client, bucketName,
+                        TestConstants.XAmzKeyV2, TestConstants.RequestEC1, TestConstants.RequestEC1);
+                }, typeof(InvalidCiphertextException));
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutGetContentUsingKMSWithDifferentRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+
+            EncryptionTestsUtils.TestPut(s3EncryptionClientMetadataModeKMSWithoutEC,
+                null, null, SampleContent, bucketName, key, TestConstants.RequestEC1);
+            
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.TestGet(key, SampleContent,
+                        s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, TestConstants.RequestEC2);
+                }, typeof(AmazonS3EncryptionClientException), TestConstants.ECNotMatched);
+            
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestGetAsync(key, SampleContent,
+                        s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, TestConstants.RequestEC2));
+                }, typeof(AmazonS3EncryptionClientException), TestConstants.ECNotMatched);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutGetContentUsingKMSWithNoECAtAll()
+        {
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
+                SampleContent, SampleContent, bucketName);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutContentUsingKMSWithRequestAndClientEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.TestPut(s3EncryptionClientMetadataModeKMSWithEC, 
+                        null, null, SampleContent, bucketName, key, TestConstants.RequestEC1);
+                }, typeof(ArgumentException), TestConstants.MultipleECErrorMesage);
+            
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.TestPut(s3EncryptionClientMetadataModeKMSWithEC, 
+                        null, null, SampleContent, bucketName, key, TestConstants.RequestEC1);
+                }, typeof(ArgumentException), TestConstants.MultipleECErrorMesage);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutGetContentUsingKMSWithReservedKeyInRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestPutAsync(
+                        s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
+                        SampleContent, bucketName, key, TestConstants.EncryptionContextWithReservedKey));
+                }, typeof(ArgumentException), TestConstants.ReservedKeyInECErrorMessage);
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.TestPut(
+                        s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
+                        SampleContent, bucketName, key, TestConstants.EncryptionContextWithReservedKey);
+                }, typeof(ArgumentException), TestConstants.ReservedKeyInECErrorMessage);
+            
+            // The version of encrypted object can only be determined after getting object from S3. 
+            // So, this is a dummy put to test get object fails.
+            EncryptionTestsUtils.TestPut(s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
+                    SampleContent, bucketName, key);
+            
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.TestGet(key, SampleContent, 
+                        s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, TestConstants.EncryptionContextWithReservedKey);
+                }, typeof(ArgumentException), TestConstants.ReservedKeyInECErrorMessage);
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestGetAsync(key, SampleContent, 
+                        s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, TestConstants.EncryptionContextWithReservedKey));
+                }, typeof(ArgumentException), TestConstants.ReservedKeyInECErrorMessage);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void MultipartEncryptionTestMetadataModeKMSWithSameRequestEC()
+        {
+            EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSWithoutEC, 
+                s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, TestConstants.RequestEC1, TestConstants.RequestEC1));
+            
+            EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMSWithoutEC, 
+                s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, TestConstants.RequestEC1, TestConstants.RequestEC1);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void MultipartEncryptionTestMetadataModeKMSWithDifferentRequestEC()
+        {
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, 
+                        TestConstants.RequestEC1, TestConstants.RequestEC2);
+                }, typeof(AmazonS3EncryptionClientException), TestConstants.ECNotMatched);
+            
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSWithoutEC, s3EncryptionClientMetadataModeKMSWithoutEC, 
+                        bucketName, TestConstants.RequestEC1, TestConstants.RequestEC2));
+                }, typeof(AmazonS3EncryptionClientException), TestConstants.ECNotMatched);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutGetContentUsingAsymmetricWrapWithRequestAndClientEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestPutAsync(s3EncryptionClientMetadataModeAsymmetricWrap, 
+                        null, null, SampleContent, bucketName, key, TestConstants.RequestEC1));
+                }, typeof(ArgumentException), TestConstants.ECNotSupported);
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.TestPut(s3EncryptionClientMetadataModeAsymmetricWrap, 
+                        null, null, SampleContent, bucketName, key, TestConstants.RequestEC1);
+                }, typeof(ArgumentException), TestConstants.ECNotSupported);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutGetContentUsingSymmetricWrapWithRequestAndClientEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.WaitForAsyncTask(EncryptionTestsUtils.TestPutAsync(s3EncryptionClientMetadataModeSymmetricWrap, 
+                        null, null, SampleContent, bucketName, key, TestConstants.RequestEC1));
+                }, typeof(ArgumentException), TestConstants.ECNotSupported);
+            
+            AssertExtensions.ExpectException(
+                () =>
+                {
+                    EncryptionTestsUtils.TestPut(s3EncryptionClientMetadataModeSymmetricWrap, null, null, 
+                        SampleContent, bucketName, key, TestConstants.RequestEC1);
+                }, typeof(ArgumentException), TestConstants.ECNotSupported);
+        }
 
         [Fact]
         [Trait(CategoryAttribute, "S3")]
         public void PutGetZeroLengthContentUsingMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMS, null, null, "", "", bucketName);
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSWithEC, null, null, "", "", bucketName);
         }
 
         [Fact]
         [Trait(CategoryAttribute, "S3")]
         public void PutGetNullContentContentUsingMetadataModeKMS()
         {
-            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMS, null, null, null, "", bucketName);
+            EncryptionTestsUtils.TestPutGet(s3EncryptionClientMetadataModeKMSWithEC, null, null, null, "", bucketName);
         }
 
         [Fact]
@@ -353,7 +564,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             AssertExtensions.ExpectException(
                 () =>
                 {
-                    EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMS, null, null, SampleContent,
+                    EncryptionTestsUtils.TestPutGet(s3EncryptionClientFileModeKMSWithEC, null, null, SampleContent,
                         SampleContent, bucketName);
                 }, typeof(AmazonClientException), InstructionAndKMSErrorMessage);
         }
@@ -362,7 +573,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void PutGetNullContentContentUsingMetadataModeKMSCalculateMD5()
         {
-            EncryptionTestsUtils.TestPutGetCalculateMD5(s3EncryptionClientMetadataModeKMS, s3EncryptionClientMetadataModeKMS, null, null, null, "", bucketName);
+            EncryptionTestsUtils.TestPutGetCalculateMD5(s3EncryptionClientMetadataModeKMSWithEC, s3EncryptionClientMetadataModeKMSWithEC, null, null, null, "", bucketName);
         }
 
         [Fact]
@@ -397,7 +608,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void MultipartEncryptionTestMetadataModeKMS()
         {
-            EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMS, bucketName);
+            EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientMetadataModeKMSWithEC, bucketName);
         }
 
         [Fact]
@@ -405,7 +616,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         public void MultipartEncryptionTestInstructionFileKMS()
         {
             AssertExtensions.ExpectException(
-                () => { EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientFileModeKMS, bucketName); },
+                () => { EncryptionTestsUtils.MultipartEncryptionTest(s3EncryptionClientFileModeKMSWithEC, bucketName); },
                 typeof(AmazonClientException), InstructionAndKMSErrorMessage);
         }
 
@@ -413,7 +624,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public void MultipartEncryptionTestMetadataModeKMSCalculateMD5()
         {
-            EncryptionTestsUtils.MultipartEncryptionTestCalculateMD5(s3EncryptionClientMetadataModeKMS, s3EncryptionClientMetadataModeKMS, bucketName);
+            EncryptionTestsUtils.MultipartEncryptionTestCalculateMD5(s3EncryptionClientMetadataModeKMSWithEC, s3EncryptionClientMetadataModeKMSWithEC, bucketName);
         }
     }
 }
\ No newline at end of file
diff --git a/test/IntegrationTests/_bcl/Utilities/AssertExtensions.cs b/test/IntegrationTests/_bcl/Utilities/AssertExtensions.cs
index ff385cd..ec11c5c 100644
--- a/test/IntegrationTests/_bcl/Utilities/AssertExtensions.cs
+++ b/test/IntegrationTests/_bcl/Utilities/AssertExtensions.cs
@@ -26,7 +26,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
 {
     public static class AssertExtensions
     {
-        public static Exception ExpectException(Action action, Type exceptionType, String expectedMessage)
+        public static Exception ExpectException(Action action, Type exceptionType, String expectedMessage = null)
         {
             Action<string> validateMessage = expectedMessage == null ? (Action<string>)null :
                 (message) =>
diff --git a/test/IntegrationTests/_bcl/Utilities/EncryptionTestsUtils.cs b/test/IntegrationTests/_bcl/Utilities/EncryptionTestsUtils.cs
index 1103977..c76d624 100644
--- a/test/IntegrationTests/_bcl/Utilities/EncryptionTestsUtils.cs
+++ b/test/IntegrationTests/_bcl/Utilities/EncryptionTestsUtils.cs
@@ -14,6 +14,7 @@
  */
 
 using System;
+using System.Collections.Generic;
 using System.Security.Cryptography;
 using System.IO;
 using System.Text;
@@ -28,6 +29,8 @@ using Amazon.KeyManagementService;
 using Amazon.KeyManagementService.Model;
 using Xunit;
 using System.Text.RegularExpressions;
+using Amazon.Extensions.S3.Encryption.Extensions;
+using Amazon.Extensions.S3.Encryption.Tests.Common;
 
 namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
 {
@@ -89,12 +92,14 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
             return uploadRequest;
         }
 
-        public static void MultipartEncryptionTest(AmazonS3Client s3EncryptionClient, string bucketName)
+        public static void MultipartEncryptionTest(AmazonS3Client s3EncryptionClient, string bucketName, 
+            Dictionary<string, string> ecInInitMPU = null, Dictionary<string, string> ecInGetRequest = null)
         {
-            MultipartEncryptionTest(s3EncryptionClient, s3EncryptionClient, bucketName);
+            MultipartEncryptionTest(s3EncryptionClient, s3EncryptionClient, bucketName, ecInInitMPU, ecInGetRequest);
         }
 
-        public static void MultipartEncryptionTest(AmazonS3Client s3EncryptionClient, IAmazonS3 s3DecryptionClient, string bucketName)
+        public static void MultipartEncryptionTest(AmazonS3Client s3EncryptionClient, IAmazonS3 s3DecryptionClient, 
+            string bucketName, Dictionary<string, string> ecInInitMPU = null, Dictionary<string, string> ecInGetRequest = null)
         {
             var guid = Guid.NewGuid();
             var filePath = Path.Combine(Path.GetTempPath(), $"multi-{guid}.txt");
@@ -114,6 +119,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
                     StorageClass = S3StorageClass.OneZoneInfrequentAccess,
                     ContentType = "text/html",
                 };
+                if (ecInInitMPU != null)
+                    initRequest.SetEncryptionContext(ecInInitMPU);
 
                 var initResponse = s3EncryptionClient.InitiateMultipartUpload(initRequest);
 
@@ -197,6 +204,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
                     BucketName = bucketName,
                     Key = key
                 };
+                if (ecInGetRequest != null)
+                    getRequest.SetEncryptionContext(ecInGetRequest);
 
                 var getResponse = s3DecryptionClient.GetObject(getRequest);
                 getResponse.WriteResponseStreamToFile(retrievedFilepath);
@@ -361,28 +370,43 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
         }
 
         internal static void TestPutGet(IAmazonS3 s3EncryptionClient,
-            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName)
+            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName,
+            string key = null, Dictionary<string, string> ecInPutRequest = null, Dictionary<string, string> ecInGetRequest = null)
         {
             TestPutGet(s3EncryptionClient, s3EncryptionClient, filePath, inputStreamBytes, contentBody,
-                expectedContent, bucketName);
+                expectedContent, bucketName, key, ecInPutRequest, ecInGetRequest);
         }
 
         internal static void TestPutGet(IAmazonS3 s3EncryptionClient, IAmazonS3 s3DecryptionClient,
-            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName)
+            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName,
+            string key = null, Dictionary<string, string> ecInPutRequest = null, Dictionary<string, string> ecInGetRequest = null)
+        {
+            if (key == null)
+                key = $"key-{Guid.NewGuid()}";
+            
+            TestPut(s3EncryptionClient, filePath, inputStreamBytes, contentBody, bucketName, key, ecInPutRequest);
+            TestGet(key, expectedContent, s3DecryptionClient, bucketName, ecInGetRequest);
+
+            WaitForAsyncTask(TestPutGetAsync(s3EncryptionClient, filePath, inputStreamBytes, contentBody, expectedContent, bucketName, ecInPutRequest, ecInGetRequest));
+        }
+        
+        internal static void TestPut(IAmazonS3 s3EncryptionClient, string filePath, byte[] inputStreamBytes, 
+            string contentBody, string bucketName, string key, Dictionary<string, string> ecInPutRequest = null)
         {
             var request = new PutObjectRequest()
             {
                 BucketName = bucketName,
-                Key = $"key-{Guid.NewGuid()}",
+                Key = key,
                 FilePath = filePath,
                 InputStream = inputStreamBytes == null ? null : new MemoryStream(inputStreamBytes),
                 ContentBody = contentBody,
             };
+            if (ecInPutRequest != null)
+            {
+                request.SetEncryptionContext(ecInPutRequest);
+            }
 
-            var response = s3EncryptionClient.PutObject(request);
-            TestGet(request.Key, expectedContent, s3DecryptionClient, bucketName);
-
-            WaitForAsyncTask(TestPutGetAsync(s3EncryptionClient, filePath, inputStreamBytes, contentBody, expectedContent, bucketName));
+            s3EncryptionClient.PutObject(request);
         }
 
         internal static void TestPutGetCalculateMD5(IAmazonS3 s3EncryptionClient, IAmazonS3 s3DecryptionClient,
@@ -403,22 +427,40 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
             WaitForAsyncTask(TestPutGetAsync(s3EncryptionClient, filePath, inputStreamBytes, contentBody, expectedContent, bucketName));
         }
 
-        private static void TestGet(string key, string uploadedData, IAmazonS3 s3EncryptionClient, string bucketName)
+        internal static void TestGet(string key, string uploadedData, IAmazonS3 s3Client, string bucketName,
+            Dictionary<string, string> requestEC = null, bool validateUploadedData = true, bool validateEC = false, 
+            Dictionary<string, string> expectedEC = null)
         {
-            var getObjectRequest = new GetObjectRequest
+            var getObjectResponse = MakeGetObjectCall((AmazonS3Client) s3Client, bucketName, key, requestEC);
+            if (validateEC)
+                CommonUtils.ValidateMaterialDescription(getObjectResponse, expectedEC);
+            if (validateUploadedData)
             {
-                BucketName = bucketName,
-                Key = key
-            };
-
-            using (var getObjectResponse = s3EncryptionClient.GetObject(getObjectRequest))
-            using (var stream = getObjectResponse.ResponseStream)
-            using (var reader = new StreamReader(stream))
-            {
-                var data = reader.ReadToEnd();
-                Assert.Equal(uploadedData, data);
+                using (var stream = getObjectResponse.ResponseStream)
+                using (var reader = new StreamReader(stream))
+                {
+                    var data = reader.ReadToEnd();
+                    Assert.Equal(uploadedData, data);
+                }
             }
         }
+        
+        public static void DecryptDataKeyWithoutS3EC(string key, AmazonS3Client s3Client, string bucketName,
+            string encryptionDataKeyLocation, Dictionary<string, string> ECToKMS = null, Dictionary<string, string> requestEC = null)
+        {
+            var getObjectResponse = MakeGetObjectCall(s3Client, bucketName, key, requestEC);
+            
+            var kmsClient = new AmazonKeyManagementServiceClient();
+            var encryptedKey = getObjectResponse.Metadata[encryptionDataKeyLocation];
+            var decryptRequest = new DecryptRequest
+            {
+                CiphertextBlob = new MemoryStream(Convert.FromBase64String(encryptedKey)),
+                EncryptionContext = ECToKMS
+            };
+            
+            // Decrypt will fail ECToKMS is incorrect
+            kmsClient.Decrypt(decryptRequest);
+        }
 
         public static void TestRangeGetDisabled(IAmazonS3 s3EncryptionClient, string bucketName)
         {
@@ -440,7 +482,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
             }, typeof(NotSupportedException), RangeGetNotSupportedMessage);
         }
 
-        private static void WaitForAsyncTask(System.Threading.Tasks.Task asyncTask)
+        internal static void WaitForAsyncTask(System.Threading.Tasks.Task asyncTask)
         {
             try
             {
@@ -452,7 +494,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
             }
         }
 
-        private static async System.Threading.Tasks.Task MultipartEncryptionTestAsync(IAmazonS3 s3EncryptionClient, IAmazonS3 s3DecryptionClient, string bucketName)
+        internal static async System.Threading.Tasks.Task MultipartEncryptionTestAsync(IAmazonS3 s3EncryptionClient, IAmazonS3 s3DecryptionClient, 
+            string bucketName, Dictionary<string, string> ecInInitMPU = null, Dictionary<string, string> ecInGetRequest = null)
         {
             var guid = Guid.NewGuid();
             var filePath = Path.Combine(Path.GetTempPath(), $"multi-{guid}.txt");
@@ -472,6 +515,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
                     StorageClass = S3StorageClass.OneZoneInfrequentAccess,
                     ContentType = "text/html"
                 };
+                if (ecInInitMPU != null)
+                    initRequest.SetEncryptionContext(ecInInitMPU);
 
                 var initResponse =
                     await s3EncryptionClient.InitiateMultipartUploadAsync(initRequest).ConfigureAwait(false);
@@ -557,6 +602,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
                     BucketName = bucketName,
                     Key = key
                 };
+                if (ecInGetRequest != null)
+                    getRequest.SetEncryptionContext(ecInGetRequest);
 
                 var getResponse =
                     await s3DecryptionClient.GetObjectAsync(getRequest).ConfigureAwait(false);
@@ -590,29 +637,45 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
         }
 
         private static async System.Threading.Tasks.Task TestPutGetAsync(IAmazonS3 s3EncryptionClient,
-            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName)
+            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName,
+            Dictionary<string, string> ecInPutRequest = null, Dictionary<string, string> ecInGetRequest = null)
+        {
+            String key = $"key-{Guid.NewGuid()}";
+
+            await TestPutAsync(s3EncryptionClient, filePath, inputStreamBytes, contentBody, bucketName, key,
+                ecInPutRequest).ConfigureAwait(false);
+            await TestGetAsync(key, expectedContent, s3EncryptionClient, bucketName, ecInGetRequest).ConfigureAwait(false);
+        }
+        
+        internal static async System.Threading.Tasks.Task TestPutAsync(IAmazonS3 s3EncryptionClient,
+            string filePath, byte[] inputStreamBytes, string contentBody, string bucketName, string key,
+            Dictionary<string, string> ecInPutRequest = null)
         {
             var request = new PutObjectRequest()
             {
                 BucketName = bucketName,
-                Key = $"key-{Guid.NewGuid()}",
+                Key = key,
                 FilePath = filePath,
                 InputStream = inputStreamBytes == null ? null : new MemoryStream(inputStreamBytes),
                 ContentBody = contentBody,
             };
-            var response = await s3EncryptionClient.PutObjectAsync(request).ConfigureAwait(false);
-            await TestGetAsync(request.Key, expectedContent, s3EncryptionClient, bucketName).ConfigureAwait(false);
+            if (ecInPutRequest != null)
+            {
+                request.SetEncryptionContext(ecInPutRequest);
+            }
+
+            await s3EncryptionClient.PutObjectAsync(request).ConfigureAwait(false);
         }
 
-        private static async System.Threading.Tasks.Task TestGetAsync(string key, string uploadedData, IAmazonS3 s3EncryptionClient, string bucketName)
+        internal static async System.Threading.Tasks.Task TestGetAsync(string key, string uploadedData, 
+            IAmazonS3 s3EncryptionClient, string bucketName, Dictionary<string, string> ecInGetRequest = null, 
+            bool validateUploadedData = true, bool validateEC = false, Dictionary<string, string> expectedEC = null)
         {
-            var getObjectRequest = new GetObjectRequest
-            {
-                BucketName = bucketName,
-                Key = key
-            };
-
-            using (var getObjectResponse = await s3EncryptionClient.GetObjectAsync(getObjectRequest).ConfigureAwait(false))
+            var getObjectResponse = await CommonUtils.MakeGetObjectAsyncCall((AmazonS3Client) s3EncryptionClient, 
+                bucketName, key, ecInGetRequest).ConfigureAwait(false);
+            if (validateEC)
+                CommonUtils.ValidateMaterialDescription(getObjectResponse, expectedEC);
+            if (validateUploadedData)
             {
                 using (var stream = getObjectResponse.ResponseStream)
                 using (var reader = new StreamReader(stream))
@@ -622,6 +685,24 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
                 }
             }
         }
+        
+        public static GetObjectResponse MakeGetObjectCall(AmazonS3Client s3Client, string bucketName, string key, 
+            Dictionary<string, string> requestEC = null)
+        {
+            GetObjectRequest getObjectRequest = new GetObjectRequest
+            {
+                BucketName = bucketName,
+                Key = key
+            };
+            if (requestEC != null)
+            {
+                getObjectRequest.SetEncryptionContext(requestEC);
+            }
+            
+            var getObjectResponse = s3Client.GetObject(getObjectRequest);
+            
+            return getObjectResponse;
+        }
 
         public static async System.Threading.Tasks.Task AttemptRangeGetAsync(IAmazonS3 s3EncryptionClient, GetObjectRequest getObjectRequest)
         {
diff --git a/test/IntegrationTests/netstandard/EncryptionTestsV1NInteropV2.cs b/test/IntegrationTests/netstandard/EncryptionTestsV1NInteropV2.cs
index a98612f..0ef4139 100644
--- a/test/IntegrationTests/netstandard/EncryptionTestsV1NInteropV2.cs
+++ b/test/IntegrationTests/netstandard/EncryptionTestsV1NInteropV2.cs
@@ -20,6 +20,7 @@ using System.Security.Cryptography;
 using System.Text;
 using Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities;
 using Amazon.Extensions.S3.Encryption.Primitives;
+using Amazon.Extensions.S3.Encryption.Tests.Common;
 using Amazon.Runtime.Internal.Util;
 using Amazon.S3;
 using AWSSDK.Extensions.S3.Encryption.IntegrationTests.NetStandard.Utilities;
@@ -35,6 +36,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
                                                                "Please set StorageMode to CryptoStorageMode.ObjectMetadata or refrain from using KMS EncryptionMaterials.";
         private static readonly string LegacyReadWhenLegacyDisabledMessage = $"The requested object is encrypted with V1 encryption schemas that have been disabled by client configuration {nameof(SecurityProfile.V2)}." +
                                                                              $" Retry with {nameof(SecurityProfile.V2AndLegacy)} enabled or reencrypt the object.";
+        
         private const string SampleContent = "Encryption Client Testing!";
 
         private static readonly byte[] SampleContentBytes = Encoding.UTF8.GetBytes(SampleContent);
@@ -58,8 +60,9 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         private AmazonS3EncryptionClientV2 s3EncryptionClientFileModeAsymmetricWrapV2;
         private AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeSymmetricWrapV2;
         private AmazonS3EncryptionClientV2 s3EncryptionClientFileModeSymmetricWrapV2;
-        private AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSV2;
-        private AmazonS3EncryptionClientV2 s3EncryptionClientFileModeKMSV2;
+        private AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSV2WithEC;
+        private AmazonS3EncryptionClientV2 s3EncryptionClientFileModeKMSV2WithEC;
+        private AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSV2WithoutEC;
 
         public EncryptionTestsV1NInteropV2(KmsKeyIdProvider kmsKeyIdProvider) : base(kmsKeyIdProvider)
         {
@@ -78,7 +81,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
 
             var asymmetricEncryptionMaterialsV2 = new EncryptionMaterialsV2(rsa, AsymmetricAlgorithmType.RsaOaepSha1);
             var symmetricEncryptionMaterialsV2 = new EncryptionMaterialsV2(aes, SymmetricAlgorithmType.AesGcm);
-            var kmsEncryptionMaterialsV2 = new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext, new Dictionary<string, string>());
+            var kmsEncryptionMaterialsV2WithEC = new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext, new Dictionary<string, string>());
+            var kmsEncryptionMaterialsV2WithoutEC = new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext);
 
             metadataConfigV2 = new AmazonS3CryptoConfigurationV2(SecurityProfile.V2AndLegacy)
             {
@@ -103,8 +107,9 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             s3EncryptionClientFileModeAsymmetricWrapV2 = new AmazonS3EncryptionClientV2(fileConfigV2, asymmetricEncryptionMaterialsV2);
             s3EncryptionClientMetadataModeSymmetricWrapV2 = new AmazonS3EncryptionClientV2(metadataConfigV2, symmetricEncryptionMaterialsV2);
             s3EncryptionClientFileModeSymmetricWrapV2 = new AmazonS3EncryptionClientV2(fileConfigV2, symmetricEncryptionMaterialsV2);
-            s3EncryptionClientMetadataModeKMSV2 = new AmazonS3EncryptionClientV2(metadataConfigV2, kmsEncryptionMaterialsV2);
-            s3EncryptionClientFileModeKMSV2 = new AmazonS3EncryptionClientV2(fileConfigV2, kmsEncryptionMaterialsV2);
+            s3EncryptionClientMetadataModeKMSV2WithEC = new AmazonS3EncryptionClientV2(metadataConfigV2, kmsEncryptionMaterialsV2WithEC);
+            s3EncryptionClientFileModeKMSV2WithEC = new AmazonS3EncryptionClientV2(fileConfigV2, kmsEncryptionMaterialsV2WithEC);
+            s3EncryptionClientMetadataModeKMSV2WithoutEC = new AmazonS3EncryptionClientV2(metadataConfigV2, kmsEncryptionMaterialsV2WithoutEC);
 
             using (var writer = File.CreateText(filePath))
             {
@@ -127,8 +132,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             s3EncryptionClientFileModeAsymmetricWrapV2.Dispose();
             s3EncryptionClientMetadataModeSymmetricWrapV2.Dispose();
             s3EncryptionClientFileModeSymmetricWrapV2.Dispose();
-            s3EncryptionClientMetadataModeKMSV2.Dispose();
-            s3EncryptionClientFileModeKMSV2.Dispose();
+            s3EncryptionClientMetadataModeKMSV2WithEC.Dispose();
+            s3EncryptionClientFileModeKMSV2WithEC.Dispose();
             
             if (File.Exists(filePath))
             {
@@ -347,13 +352,13 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV2, s3EncryptionClientFileModeKMSV1N,
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV2WithEC, s3EncryptionClientFileModeKMSV1N,
                     filePath, null, null, SampleContent, bucketName));
             }, InstructionAndKMSErrorMessageV2);
 
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2,
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2WithEC,
                     filePath, null, null, SampleContent, bucketName));
             }, InstructionAndKMSErrorMessageV1N);
         }
@@ -362,11 +367,11 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute,"S3")]
         public async void PutGetStreamUsingMetadataModeKMS()
         {
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N,
                 null, SampleContentBytes, null, SampleContent, bucketName)
                 .ConfigureAwait(false);
 
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                 null, SampleContentBytes, null, SampleContent, bucketName)
                 .ConfigureAwait(false);
         }
@@ -377,13 +382,13 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => { return EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV2, s3EncryptionClientFileModeKMSV1N,
+                AsyncHelpers.RunSync(() => { return EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV2WithEC, s3EncryptionClientFileModeKMSV1N,
                     null, SampleContentBytes, null, SampleContent, bucketName); });
             }, InstructionAndKMSErrorMessageV2);
 
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => { return EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2,
+                AsyncHelpers.RunSync(() => { return EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2WithEC,
                     null, SampleContentBytes, null, SampleContent, bucketName); });
             }, InstructionAndKMSErrorMessageV1N);
         }
@@ -392,24 +397,102 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute,"S3")]
         public async void PutGetContentUsingMetadataModeKMS()
         {
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N,
                 null, null, SampleContent, SampleContent, bucketName)
                 .ConfigureAwait(false);
 
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                 null, null, SampleContent, SampleContent, bucketName)
                 .ConfigureAwait(false);
         }
+        
+        [Fact]
+        [Trait(CategoryAttribute,"S3")]
+        public async void PerRequestEncryptionContextOnV1ObjectRejected()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            // V1 Object does not support request level EC.
+            // Fails as we are trying to put V1 object with request EC
+            var exceptionOnPut = await Assert.ThrowsAsync<ArgumentException>(async () =>
+            {
+                await EncryptionTestsUtils.TestPutAsync(
+                    s3EncryptionClientMetadataModeKMSV1N,
+                    null, null, SampleContent,
+                    bucketName, key, TestConstants.RequestEC1).ConfigureAwait(false);
+            });
+            Assert.Contains(TestConstants.ECNotSupported, exceptionOnPut.Message);
+                
+            await EncryptionTestsUtils.TestPutAsync(
+                s3EncryptionClientMetadataModeKMSV1N,
+                null, null, SampleContent,
+                bucketName, key).ConfigureAwait(false);
+            
+            // Fails as this is trying to get V1 object with request EC
+            var exceptionOnGetWithV1Client = await Assert.ThrowsAsync<ArgumentException>(async () =>
+            {
+                await EncryptionTestsUtils.TestGetAsync(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV1N, 
+                    bucketName, TestConstants.RequestEC1).ConfigureAwait(false);
+            });
+            Assert.Contains(TestConstants.ECNotSupported, exceptionOnGetWithV1Client.Message);
+            
+            // Fails as this is trying to get V1 object with request EC even in V2AndLegacy
+            var exceptionOnGetWithV2Client = await Assert.ThrowsAsync<ArgumentException>(async () =>
+            {
+                await EncryptionTestsUtils.TestGetAsync(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV2WithoutEC, 
+                    bucketName, TestConstants.RequestEC1).ConfigureAwait(false);
+            });
+            Assert.Contains(TestConstants.ECNotSupported, exceptionOnGetWithV2Client.Message);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute,"S3")]
+        public async void V2PutV1GetWithSameRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            await EncryptionTestsUtils.TestPutAsync(
+                s3EncryptionClientMetadataModeKMSV2WithoutEC,
+                null, null, SampleContent,
+                bucketName, key, TestConstants.RequestEC1).ConfigureAwait(false);
+            
+            // Succeeds as this is trying to get v2 object even with v1 client
+            await EncryptionTestsUtils.TestGetAsync(
+                key, SampleContent, s3EncryptionClientMetadataModeKMSV1N,
+                bucketName, TestConstants.RequestEC1).ConfigureAwait(false);
+            
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute,"S3")]
+        public async void V2PutV1GetWithDifferentRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            await EncryptionTestsUtils.TestPutAsync(
+                s3EncryptionClientMetadataModeKMSV2WithoutEC,
+                null, null, SampleContent,
+                bucketName, key, TestConstants.RequestEC1).ConfigureAwait(false);
+            var exception = await Assert.ThrowsAsync<AmazonS3EncryptionClientException>(async () =>
+            {
+                await EncryptionTestsUtils.TestGetAsync(
+                    key, SampleContent, s3EncryptionClientMetadataModeKMSV1N, 
+                    bucketName, TestConstants.RequestEC2).ConfigureAwait(false);
+            });
+            Assert.Contains(TestConstants.ECNotMatched, exception.Message);
+        }
 
         [Fact]
         [Trait(CategoryAttribute,"S3")]
         public async void PutGetZeroLengthContentUsingMetadataModeKMS()
         {
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N,
                 null, null, "", "", bucketName)
                 .ConfigureAwait(false);
 
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                 null, null, "", "", bucketName)
                 .ConfigureAwait(false);
         }
@@ -418,11 +501,11 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute,"S3")]
         public async void PutGetNullContentContentUsingMetadataModeKMS()
         {
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N,
                 null, null, null, "", bucketName)
                 .ConfigureAwait(false);
 
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                 null, null, null, "", bucketName)
                 .ConfigureAwait(false);
         }
@@ -433,13 +516,13 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV2, s3EncryptionClientFileModeKMSV1N,
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV2WithEC, s3EncryptionClientFileModeKMSV1N,
                     null, null, SampleContent, SampleContent, bucketName));
             }, InstructionAndKMSErrorMessageV2);
 
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2,
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2WithEC,
                     null, null, SampleContent, SampleContent, bucketName));
             }, InstructionAndKMSErrorMessageV1N);
         }
@@ -492,10 +575,10 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute,"S3")]
         public async void MultipartEncryptionTestMetadataModeKMS()
         {
-            await EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSV2, s3EncryptionClientMetadataModeKMSV1N, bucketName)
+            await EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSV2WithEC, s3EncryptionClientMetadataModeKMSV1N, bucketName)
                 .ConfigureAwait(false);
 
-            await EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2, bucketName)
+            await EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC, bucketName)
                 .ConfigureAwait(false);
         }
 
@@ -505,12 +588,12 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientFileModeKMSV2, s3EncryptionClientFileModeKMSV1N, bucketName));
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientFileModeKMSV2WithEC, s3EncryptionClientFileModeKMSV1N, bucketName));
             }, InstructionAndKMSErrorMessageV2);
 
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2, bucketName));
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientFileModeKMSV1N, s3EncryptionClientFileModeKMSV2WithEC, bucketName));
             }, InstructionAndKMSErrorMessageV1N);
         }
 
@@ -523,7 +606,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             AssertExtensions.ExpectException(() =>
             {
                 AsyncHelpers.RunSync(() =>
-                    EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2,
+                    EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSV1N, s3EncryptionClientMetadataModeKMSV2WithEC,
                         filePath, null, null, SampleContent, bucketName)
                 );
             }, LegacyReadWhenLegacyDisabledMessage);
diff --git a/test/IntegrationTests/netstandard/EncryptionTestsV2.cs b/test/IntegrationTests/netstandard/EncryptionTestsV2.cs
index 523537c..77b2fd8 100644
--- a/test/IntegrationTests/netstandard/EncryptionTestsV2.cs
+++ b/test/IntegrationTests/netstandard/EncryptionTestsV2.cs
@@ -21,6 +21,7 @@ using System.Text;
 using System.Threading.Tasks;
 using Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities;
 using Amazon.Extensions.S3.Encryption.Primitives;
+using Amazon.Extensions.S3.Encryption.Tests.Common;
 using Amazon.KeyManagementService.Model;
 using Amazon.Runtime.Internal.Util;
 using Amazon.S3;
@@ -35,13 +36,13 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         private const string InstructionAndKMSErrorMessage =
             "AmazonS3EncryptionClientV2 only supports KMS key wrapping in metadata storage mode. " +
             "Please set StorageMode to CryptoStorageMode.ObjectMetadata or refrain from using KMS EncryptionMaterials.";
-
+        
         private const string sampleContent = "Encryption Client Testing!";
 
         private static readonly byte[] sampleContentBytes = Encoding.UTF8.GetBytes(sampleContent);
 
         private string filePath = EncryptionTestsUtils.GetRandomFilePath(EncryptionTestsUtils.EncryptionPutObjectFilePrefix);
-
+        
         private string bucketName;
         private string kmsKeyID;
 
@@ -49,8 +50,9 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         private AmazonS3EncryptionClientV2 s3EncryptionClientFileModeAsymmetricWrap;
         private AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeSymmetricWrap;
         private AmazonS3EncryptionClientV2 s3EncryptionClientFileModeSymmetricWrap;
-        private AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMS;
-        private AmazonS3EncryptionClientV2 s3EncryptionClientFileModeKMS;
+        private AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSWithEC;
+        private AmazonS3EncryptionClientV2 s3EncryptionClientFileModeKMSWithEC;
+        private AmazonS3EncryptionClientV2 s3EncryptionClientMetadataModeKMSWithoutEC;
 
         private AmazonS3Client s3Client;
 
@@ -63,9 +65,10 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
 
             var asymmetricEncryptionMaterials = new EncryptionMaterialsV2(rsa, AsymmetricAlgorithmType.RsaOaepSha1);
             var symmetricEncryptionMaterials = new EncryptionMaterialsV2(aes, SymmetricAlgorithmType.AesGcm);
-            var kmsEncryptionMaterials =
+            var kmsEncryptionMaterialsWithEC =
                 new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext, new Dictionary<string, string>());
-
+            var kmsEncryptionMaterialsWithoutEC =
+                new EncryptionMaterialsV2(kmsKeyID, KmsType.KmsContext);
             var fileConfig = new AmazonS3CryptoConfigurationV2(SecurityProfile.V2)
             {
                 StorageMode = CryptoStorageMode.InstructionFile
@@ -85,8 +88,9 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
                 new AmazonS3EncryptionClientV2(metadataConfig, symmetricEncryptionMaterials);
             s3EncryptionClientFileModeSymmetricWrap =
                 new AmazonS3EncryptionClientV2(fileConfig, symmetricEncryptionMaterials);
-            s3EncryptionClientMetadataModeKMS = new AmazonS3EncryptionClientV2(metadataConfig, kmsEncryptionMaterials);
-            s3EncryptionClientFileModeKMS = new AmazonS3EncryptionClientV2(fileConfig, kmsEncryptionMaterials);
+            s3EncryptionClientMetadataModeKMSWithEC = new AmazonS3EncryptionClientV2(metadataConfig, kmsEncryptionMaterialsWithEC);
+            s3EncryptionClientFileModeKMSWithEC = new AmazonS3EncryptionClientV2(fileConfig, kmsEncryptionMaterialsWithEC);
+            s3EncryptionClientMetadataModeKMSWithoutEC = new AmazonS3EncryptionClientV2(metadataConfig, kmsEncryptionMaterialsWithoutEC);
 
             s3Client = new AmazonS3Client();
 
@@ -109,8 +113,9 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             s3EncryptionClientFileModeAsymmetricWrap.Dispose();
             s3EncryptionClientMetadataModeSymmetricWrap.Dispose();
             s3EncryptionClientFileModeSymmetricWrap.Dispose();
-            s3EncryptionClientMetadataModeKMS.Dispose();
-            s3EncryptionClientFileModeKMS.Dispose();
+            s3EncryptionClientMetadataModeKMSWithEC.Dispose();
+            s3EncryptionClientFileModeKMSWithEC.Dispose();
+            s3EncryptionClientMetadataModeKMSWithoutEC.Dispose();
             if (File.Exists(filePath))
             {
                 File.Delete(filePath);
@@ -289,7 +294,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMS,
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSWithEC,
                     filePath, null, null, sampleContent, bucketName));
             }, InstructionAndKMSErrorMessage);
         }
@@ -298,7 +303,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public async Task PutGetStreamUsingMetadataModeKMS()
         {
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMS, null, sampleContentBytes,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSWithEC, null, sampleContentBytes,
                 null, sampleContent, bucketName).ConfigureAwait(false);
         }
 
@@ -308,7 +313,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMS,
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSWithEC,
                     null, sampleContentBytes, null, sampleContent, bucketName));
             }, InstructionAndKMSErrorMessage);
         }
@@ -317,16 +322,151 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public async Task PutGetContentUsingMetadataModeKMS()
         {
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMS, null, null,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSWithEC, null, null,
+                sampleContent, sampleContent, bucketName).ConfigureAwait(false);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public async Task PutGetContentUsingKMSWithSameRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            var encryptionContext = new Dictionary<string, string>(TestConstants.RequestEC1);
+            var expectedEncryptionContext = encryptionContext;
+
+            expectedEncryptionContext.Add(TestConstants.XAmzEncryptionContextCekAlg, TestConstants.XAmzAesGcmCekAlgValue);
+            
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
+                sampleContent, sampleContent, bucketName, key, TestConstants.RequestEC1, TestConstants.RequestEC1).ConfigureAwait(false);
+            
+            // This proves the material description in S3 is what we expect.
+            await EncryptionTestsUtils.TestGetAsync(
+                key, sampleContent, s3Client, bucketName,
+                TestConstants.RequestEC1, false, true, expectedEncryptionContext)
+                .ConfigureAwait(false);
+            
+            // This proves the EC we are sending to KMS is actually the EC we expect without using S3EC at all.
+            await CommonUtils.DecryptDataKeyWithoutS3ECAsync(key, s3Client, bucketName,
+                TestConstants.XAmzKeyV2, expectedEncryptionContext, TestConstants.RequestEC1)
+                .ConfigureAwait(false);
+            
+            // This is expected to fail as TestConstants.RequestEC1 does not have reserved key.
+            AssertExtensions.ExpectException<InvalidCiphertextException>(() =>
+            {
+                AsyncHelpers.RunSync(() => CommonUtils.DecryptDataKeyWithoutS3ECAsync(key, s3Client, bucketName,
+                    TestConstants.XAmzKeyV2, TestConstants.RequestEC1, TestConstants.RequestEC1));
+            });
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public async Task PutGetContentUsingKMSWithDifferentRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            await EncryptionTestsUtils.TestPutAsync(s3EncryptionClientMetadataModeKMSWithoutEC, null, null, 
+                sampleContent, bucketName, key, TestConstants.RequestEC1).ConfigureAwait(false);
+            
+            AssertExtensions.ExpectException<AmazonS3EncryptionClientException>(() =>
+            {
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestGetAsync(key, sampleContent, 
+                    s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, TestConstants.RequestEC2));
+            }, TestConstants.ECNotMatched);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public async Task PutGetContentUsingKMSWithNoECAtAll()
+        {
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
                 sampleContent, sampleContent, bucketName).ConfigureAwait(false);
         }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutContentUsingKMSWithRequestAndClientEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            
+            AssertExtensions.ExpectException<ArgumentException>(() =>
+            {
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutAsync(s3EncryptionClientMetadataModeKMSWithEC, 
+                    null, null, sampleContent, bucketName, key, TestConstants.RequestEC1));
+            }, TestConstants.MultipleECErrorMesage);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public async Task PutGetContentUsingKMSWithReservedKeyInRequestEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            AssertExtensions.ExpectException<ArgumentException>(() =>
+            {
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutAsync(s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
+                        sampleContent, bucketName, key, TestConstants.EncryptionContextWithReservedKey));
+            }, TestConstants.ReservedKeyInECErrorMessage);
+            
+            // The version of encrypted object can only be determined after getting object from S3. 
+            // So, this is a dummy put to test get object fails.
+            await EncryptionTestsUtils.TestPutAsync(s3EncryptionClientMetadataModeKMSWithoutEC, null, null,
+                    sampleContent, bucketName, key)
+                .ConfigureAwait(false);
+            
+            AssertExtensions.ExpectException<ArgumentException>(() =>
+            {
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestGetAsync(key, sampleContent, 
+                    s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, TestConstants.EncryptionContextWithReservedKey));
+            }, TestConstants.ReservedKeyInECErrorMessage);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public async Task MultipartEncryptionTestMetadataModeKMSWithSameRequestEC()
+        {
+            await EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, 
+                TestConstants.RequestEC1, TestConstants.RequestEC1);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void MultipartEncryptionTestMetadataModeKMSWithDifferentRequestEC()
+        {
+            AssertExtensions.ExpectException<AmazonS3EncryptionClientException>(() =>
+            {
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSWithoutEC, bucketName, 
+                    TestConstants.RequestEC1, TestConstants.RequestEC2));
+            }, TestConstants.ECNotMatched);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutGetContentUsingAsymmetricWrapWithRequestAndClientEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            AssertExtensions.ExpectException<ArgumentException>(() =>
+            {
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutAsync(s3EncryptionClientMetadataModeAsymmetricWrap, 
+                    null, null, sampleContent, bucketName, key, TestConstants.RequestEC1));
+            }, TestConstants.ECNotSupported);
+        }
+        
+        [Fact]
+        [Trait(CategoryAttribute, "S3")]
+        public void PutGetContentUsingSymmetricWrapWithRequestAndClientEC()
+        {
+            var key = $"key-{Guid.NewGuid()}";
+            AssertExtensions.ExpectException<ArgumentException>(() =>
+            {
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutAsync(s3EncryptionClientMetadataModeSymmetricWrap, 
+                    null, null, sampleContent, bucketName, key, TestConstants.RequestEC1));
+            }, TestConstants.ECNotSupported);
+        }
 
         [Fact]
         [Trait(CategoryAttribute, "S3")]
         public async Task PutGetContentWithTemperedEncryptionContextUsingMetadataModeKMS()
         {
             // Put encrypted content
-            var key = await PutContentAsync(s3EncryptionClientMetadataModeKMS, null, null,
+            var key = await PutContentAsync(s3EncryptionClientMetadataModeKMSWithEC, null, null,
                 sampleContent, sampleContent, bucketName).ConfigureAwait(false);
 
             // Temper the cek algorithm
@@ -336,7 +476,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
             AssertExtensions.ExpectException<InvalidCiphertextException>(() =>
             {
                 AsyncHelpers.RunSync(() =>
-                    EncryptionTestsUtils.TestGetAsync(key, sampleContent, s3EncryptionClientMetadataModeKMS,
+                    EncryptionTestsUtils.TestGetAsync(key, sampleContent, s3EncryptionClientMetadataModeKMSWithEC,
                         bucketName));
             });
         }
@@ -345,7 +485,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public async Task PutGetZeroLengthContentUsingMetadataModeKMS()
         {
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMS, null, null,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSWithEC, null, null,
                 "", "", bucketName).ConfigureAwait(false);
         }
 
@@ -353,7 +493,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public async Task PutGetNullContentContentUsingMetadataModeKMS()
         {
-            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMS, null, null,
+            await EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientMetadataModeKMSWithEC, null, null,
                 null, "", bucketName).ConfigureAwait(false);
         }
 
@@ -361,7 +501,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public async Task PutGetNullContentContentUsingMetadataModeKMSCalculateMD5()
         {
-            await EncryptionTestsUtils.TestPutGetCalculateMD5Async(s3EncryptionClientMetadataModeKMS, s3EncryptionClientMetadataModeKMS, null, null,
+            await EncryptionTestsUtils.TestPutGetCalculateMD5Async(s3EncryptionClientMetadataModeKMSWithEC, s3EncryptionClientMetadataModeKMSWithEC, null, null,
                 null, "", bucketName).ConfigureAwait(false);
         }
 
@@ -371,7 +511,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         {
             AssertExtensions.ExpectException(() =>
             {
-                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMS, null,
+                AsyncHelpers.RunSync(() => EncryptionTestsUtils.TestPutGetAsync(s3EncryptionClientFileModeKMSWithEC, null,
                     null, sampleContent, sampleContent, bucketName));
             }, InstructionAndKMSErrorMessage);
         }
@@ -412,14 +552,14 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
         [Trait(CategoryAttribute, "S3")]
         public async Task MultipartEncryptionTestMetadataModeKMS()
         {
-            await EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMS, bucketName);
+            await EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientMetadataModeKMSWithEC, bucketName);
         }
 
         [Fact]
         [Trait(CategoryAttribute, "S3")]
         public async Task MultipartEncryptionTestMetadataModeKMSCalculateMD5()
         {
-            await EncryptionTestsUtils.MultipartEncryptionTestCalculateMD5Async(s3EncryptionClientMetadataModeKMS, s3EncryptionClientMetadataModeKMS, bucketName);
+            await EncryptionTestsUtils.MultipartEncryptionTestCalculateMD5Async(s3EncryptionClientMetadataModeKMSWithEC, s3EncryptionClientMetadataModeKMSWithEC, bucketName);
         }
 
         [Fact]
@@ -430,7 +570,7 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests
                 () =>
                 {
                     AsyncHelpers.RunSync(() =>
-                        EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientFileModeKMS, bucketName));
+                        EncryptionTestsUtils.MultipartEncryptionTestAsync(s3EncryptionClientFileModeKMSWithEC, bucketName));
                 }, InstructionAndKMSErrorMessage);
         }
 
diff --git a/test/IntegrationTests/netstandard/Utilities/EncryptionTestsUtils.cs b/test/IntegrationTests/netstandard/Utilities/EncryptionTestsUtils.cs
index f2f5c9c..1b52d9e 100644
--- a/test/IntegrationTests/netstandard/Utilities/EncryptionTestsUtils.cs
+++ b/test/IntegrationTests/netstandard/Utilities/EncryptionTestsUtils.cs
@@ -14,9 +14,15 @@
  */
 
 using System;
+using System.Collections.Generic;
 using System.IO;
+using System.Text.Json;
 using System.Threading;
 using System.Threading.Tasks;
+using Amazon.Extensions.S3.Encryption.Extensions;
+using Amazon.Extensions.S3.Encryption.Tests.Common;
+using Amazon.KeyManagementService;
+using Amazon.KeyManagementService.Model;
 using Amazon.S3;
 using Amazon.S3.Model;
 using Xunit;
@@ -27,13 +33,16 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
     {
         private const long MegaBytesSize = 1048576;
 
-        public static async Task MultipartEncryptionTestAsync(AmazonS3Client s3EncryptionClient, string bucketName)
+        public static async Task MultipartEncryptionTestAsync(AmazonS3Client s3EncryptionClient, string bucketName,
+            Dictionary<string, string> ecInInitMPU = null, Dictionary<string, string> ecInGetRequest = null)
         {
-            await MultipartEncryptionTestAsync(s3EncryptionClient, s3EncryptionClient, bucketName);
+            await MultipartEncryptionTestAsync(s3EncryptionClient, s3EncryptionClient, bucketName,
+                ecInInitMPU, ecInGetRequest);
         }
 
         public static async Task MultipartEncryptionTestAsync(AmazonS3Client s3EncryptionClient,
-            AmazonS3Client s3DecryptionClient, string bucketName)
+            AmazonS3Client s3DecryptionClient, string bucketName, Dictionary<string, string> ecInInitMPU = null, 
+            Dictionary<string, string> ecInGetRequest = null)
         {
             var filePath = Path.GetTempFileName();
             var retrievedFilepath = Path.GetTempFileName();
@@ -52,6 +61,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
                     StorageClass = S3StorageClass.OneZoneInfrequentAccess,
                     ContentType = "text/html",
                 };
+                if (ecInInitMPU != null)
+                    initRequest.SetEncryptionContext(ecInInitMPU);
 
                 InitiateMultipartUploadResponse initResponse =
                     await s3EncryptionClient.InitiateMultipartUploadAsync(initRequest).ConfigureAwait(false);
@@ -141,6 +152,8 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
                     BucketName = bucketName,
                     Key = key
                 };
+                if (ecInGetRequest != null)
+                    getRequest.SetEncryptionContext(ecInGetRequest);
 
                 GetObjectResponse getResponse =
                     await s3DecryptionClient.GetObjectAsync(getRequest).ConfigureAwait(false);
@@ -303,13 +316,25 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
         }
 
         public static async Task TestPutGetAsync(AmazonS3Client s3EncryptionClient,
-            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName)
+            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName,
+            string key = null, Dictionary<string, string> ecInPutRequest = null, Dictionary<string, string> ecInGetRequest = null)
         {
             await TestPutGetAsync(s3EncryptionClient, s3EncryptionClient, filePath, inputStreamBytes, contentBody,
-                expectedContent, bucketName);
+                expectedContent, bucketName, key, ecInPutRequest, ecInGetRequest);
         }
 
         public static async Task TestPutGetAsync(AmazonS3Client s3EncryptionClient, AmazonS3Client s3DecryptionClient,
+            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName,
+            string key = null, Dictionary<string, string> ecInPutRequest = null, Dictionary<string, string> ecInGetRequest = null)
+        {
+            if (key == null)
+                key = $"key-{Guid.NewGuid()}";
+            await TestPutAsync(s3EncryptionClient, filePath, inputStreamBytes, contentBody,
+                bucketName, key, ecInPutRequest).ConfigureAwait(false);
+            await TestGetAsync(key, expectedContent, s3DecryptionClient, bucketName, ecInGetRequest).ConfigureAwait(false);
+        }
+
+        public static async Task TestPutGetCalculateMD5Async(AmazonS3Client s3EncryptionClient, AmazonS3Client s3DecryptionClient,
             string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName)
         {
             PutObjectRequest request = new PutObjectRequest()
@@ -318,46 +343,79 @@ namespace Amazon.Extensions.S3.Encryption.IntegrationTests.Utilities
                 Key = $"key-{Guid.NewGuid()}",
                 FilePath = filePath,
                 InputStream = inputStreamBytes == null ? null : new MemoryStream(inputStreamBytes),
-                ContentBody = contentBody,
+                ContentBody = contentBody
             };
             PutObjectResponse response = await s3EncryptionClient.PutObjectAsync(request).ConfigureAwait(false);
             await TestGetAsync(request.Key, expectedContent, s3DecryptionClient, bucketName).ConfigureAwait(false);
         }
-
-        public static async Task TestPutGetCalculateMD5Async(AmazonS3Client s3EncryptionClient, AmazonS3Client s3DecryptionClient,
-            string filePath, byte[] inputStreamBytes, string contentBody, string expectedContent, string bucketName)
+        
+        public static async Task TestPutAsync(AmazonS3Client s3EncryptionClient, string filePath, 
+            byte[] inputStreamBytes, string contentBody, string bucketName, string key, 
+            Dictionary<string, string> ec = null)
         {
             PutObjectRequest request = new PutObjectRequest()
             {
                 BucketName = bucketName,
-                Key = $"key-{Guid.NewGuid()}",
+                Key = key,
                 FilePath = filePath,
                 InputStream = inputStreamBytes == null ? null : new MemoryStream(inputStreamBytes),
-                ContentBody = contentBody
+                ContentBody = contentBody,
             };
-            PutObjectResponse response = await s3EncryptionClient.PutObjectAsync(request).ConfigureAwait(false);
-            await TestGetAsync(request.Key, expectedContent, s3DecryptionClient, bucketName).ConfigureAwait(false);
+            if (ec != null)
+            {
+                request.SetEncryptionContext(ec);
+            }
+            await s3EncryptionClient.PutObjectAsync(request).ConfigureAwait(false);
+        }
+
+        public static async Task TestGetAsync(string key, string uploadedData, AmazonS3Client s3Client,
+            string bucketName, Dictionary<string, string> requestEC = null, bool validateUploadedData = true, 
+            bool validateEC = false, Dictionary<string, string> expectedEC = null)
+        {
+            var getObjectResponse = await CommonUtils.MakeGetObjectAsyncCall(s3Client, bucketName, key, requestEC);
+            if (validateEC)
+                CommonUtils.ValidateMaterialDescription(getObjectResponse, expectedEC);
+            if (validateUploadedData)
+            {
+                using var reader = new StreamReader(getObjectResponse.ResponseStream);
+                string data = await reader.ReadToEndAsync();
+                Assert.Equal(uploadedData, data);
+            }
         }
 
-        public static async Task TestGetAsync(string key, string uploadedData, AmazonS3Client s3EncryptionClient,
-            string bucketName)
+        public static async Task DecryptDataKeyWithoutS3ECAsync(string key, AmazonS3Client s3Client, string bucketName,
+            string encryptionDataKeyLocation, Dictionary<string, string> ECToKMS = null, Dictionary<string, string> requestEC = null)
+        {
+            var getObjectResponse = await CommonUtils.MakeGetObjectAsyncCall(s3Client, bucketName, key, requestEC);
+            
+            var kmsClient = new AmazonKeyManagementServiceClient();
+            var encryptedKey = getObjectResponse.Metadata[encryptionDataKeyLocation];
+            var decryptRequest = new DecryptRequest
+            {
+                CiphertextBlob = new MemoryStream(Convert.FromBase64String(encryptedKey)),
+                EncryptionContext = ECToKMS
+            };
+            
+            // Decrypt will fail ECToKMS is incorrect
+            await kmsClient.DecryptAsync(decryptRequest);
+        }
+        
+        public static async Task<GetObjectResponse> getObject(AmazonS3Client s3Client, string bucketName, string key, 
+            Dictionary<string, string> requestEC = null)
         {
             GetObjectRequest getObjectRequest = new GetObjectRequest
             {
                 BucketName = bucketName,
                 Key = key
             };
-
-            using (GetObjectResponse getObjectResponse =
-                await s3EncryptionClient.GetObjectAsync(getObjectRequest).ConfigureAwait(false))
+            if (requestEC != null)
             {
-                using (var stream = getObjectResponse.ResponseStream)
-                using (var reader = new StreamReader(stream))
-                {
-                    string data = reader.ReadToEnd();
-                    Assert.Equal(uploadedData, data);
-                }
+                getObjectRequest.SetEncryptionContext(requestEC);
             }
+        
+            var getObjectResponse = await s3Client.GetObjectAsync(getObjectRequest).ConfigureAwait(false);
+        
+            return getObjectResponse;
         }
 
         public static async Task AttemptRangeGet(IAmazonS3 s3EncryptionClient, string bucketName)
diff --git a/test/UnitTests/Amazon.Extensions.S3.Encryption.UnitTests.csproj b/test/UnitTests/Amazon.Extensions.S3.Encryption.UnitTests.csproj
index ed4f6c0..0d10fe5 100644
--- a/test/UnitTests/Amazon.Extensions.S3.Encryption.UnitTests.csproj
+++ b/test/UnitTests/Amazon.Extensions.S3.Encryption.UnitTests.csproj
@@ -2,6 +2,8 @@
     <PropertyGroup>
         <TargetFrameworks>net472;net8</TargetFrameworks>
         <IsPackable>false</IsPackable>
+        <SignAssembly>true</SignAssembly>
+        <AssemblyOriginatorKeyFile>..\..\public.snk</AssemblyOriginatorKeyFile>
 	</PropertyGroup>
 
     <ItemGroup>
@@ -20,5 +22,6 @@
 
     <ItemGroup>
         <ProjectReference Include="..\..\src\Amazon.Extensions.S3.Encryption.csproj" />
+        <ProjectReference Include="..\Common\Amazon.Extensions.S3.Encryption.Tests.Common.csproj" />
     </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/test/UnitTests/Extension/S3RequestExtensionsTests.cs b/test/UnitTests/Extension/S3RequestExtensionsTests.cs
new file mode 100644
index 0000000..713fcc4
--- /dev/null
+++ b/test/UnitTests/Extension/S3RequestExtensionsTests.cs
@@ -0,0 +1,198 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+using System.Collections.Generic;
+using Amazon.Extensions.S3.Encryption.Extensions;
+using Amazon.Extensions.S3.Encryption.Tests.Common;
+using Amazon.Extensions.S3.Encryption.Util;
+using Amazon.S3.Model;
+using Xunit;
+
+namespace Amazon.Extensions.S3.Encryption.UnitTests.Extension
+{
+    public class S3RequestExtensionsTests
+    {
+        [Fact]
+        public void SetEncryptionContext_StoresContextCorrectly()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            
+            putObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            getObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            initiateMultipartUploadRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            
+            var retrievedECForPut = EncryptionContextUtils.GetEncryptionContextFromRequest(putObjectRequest);
+            var retrievedECForGet = EncryptionContextUtils.GetEncryptionContextFromRequest(getObjectRequest);
+            var retrievedECForInitMPU = EncryptionContextUtils.GetEncryptionContextFromRequest(initiateMultipartUploadRequest);
+            
+            // Reserved keys are only added when client performs API requests
+            Assert.False(retrievedECForPut.ContainsKey(EncryptionUtils.XAmzEncryptionContextCekAlg));
+            
+            Assert.True(retrievedECForPut.ContainsKey(TestConstants.RequestEC1Key));
+            Assert.Equal(TestConstants.RequestEC1Value, retrievedECForPut[TestConstants.RequestEC1Key]);
+            
+            Assert.Equal(retrievedECForPut, TestConstants.RequestEC1);
+            Assert.Equal(retrievedECForPut, retrievedECForGet);
+            Assert.Equal(retrievedECForGet, retrievedECForInitMPU);
+        }
+
+        [Fact]
+        public void GetEncryptionContext_ReturnsNullWhenNotSet()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+
+            var retrievedECForPut = EncryptionContextUtils.GetEncryptionContextFromRequest(putObjectRequest);
+            var retrievedECForGet = EncryptionContextUtils.GetEncryptionContextFromRequest(getObjectRequest);
+            var retrievedECForInitMPU = EncryptionContextUtils.GetEncryptionContextFromRequest(initiateMultipartUploadRequest);
+
+            Assert.Null(retrievedECForPut);
+            Assert.Null(retrievedECForGet);
+            Assert.Null(retrievedECForInitMPU);
+        }
+
+        [Fact]
+        public void SetEncryptionContext_WithReservedKey_DoesNotThrowsArgumentException()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            
+            // Does not throw exception as putObjectRequest is not associated with client. 
+            // throws exception if it is used with V2 client
+            putObjectRequest.SetEncryptionContext(TestConstants.EncryptionContextWithReservedKey);
+            getObjectRequest.SetEncryptionContext(TestConstants.EncryptionContextWithReservedKey);
+            initiateMultipartUploadRequest.SetEncryptionContext(TestConstants.EncryptionContextWithReservedKey);
+        }
+
+        [Fact]
+        public void SetEncryptionContext_MultipleCalls_ReplacesContext()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            
+            var firstEncryptionContext = new Dictionary<string, string> { { "first", "value1" } };
+            var secondEncryptionContext = new Dictionary<string, string> { { "second", "value2" } };
+            
+            // set EC
+            putObjectRequest.SetEncryptionContext(firstEncryptionContext);
+            getObjectRequest.SetEncryptionContext(firstEncryptionContext);
+            initiateMultipartUploadRequest.SetEncryptionContext(firstEncryptionContext);
+            
+            // replace EC
+            putObjectRequest.SetEncryptionContext(secondEncryptionContext);
+            getObjectRequest.SetEncryptionContext(secondEncryptionContext);
+            initiateMultipartUploadRequest.SetEncryptionContext(secondEncryptionContext);
+            
+            var retrievedECForPut = EncryptionContextUtils.GetEncryptionContextFromRequest(putObjectRequest);
+            var retrievedECForGet = EncryptionContextUtils.GetEncryptionContextFromRequest(getObjectRequest);
+            var retrievedECForInitMPU = EncryptionContextUtils.GetEncryptionContextFromRequest(initiateMultipartUploadRequest);
+            
+            Assert.NotNull(retrievedECForPut);
+            Assert.False(retrievedECForPut.ContainsKey("first"));
+            Assert.Equal("value2", retrievedECForPut["second"]);
+            
+            Assert.Equal(retrievedECForPut, retrievedECForGet);
+            Assert.Equal(retrievedECForGet, retrievedECForInitMPU);
+        }
+
+        [Fact]
+        public void SetEncryptionContext_DoesNotModifyOriginalDictionary()
+        {
+            // Internally, S3EC adds reserved key-value pair to the encryption context.
+            // This test ensures encryption context passed by the user is not modified on users end
+            // and is only modified internally.
+            
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+
+            putObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            Assert.False(TestConstants.RequestEC1.ContainsKey(EncryptionUtils.XAmzEncryptionContextCekAlg));
+            
+            getObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            Assert.False(TestConstants.RequestEC1.ContainsKey(EncryptionUtils.XAmzEncryptionContextCekAlg));
+            
+            initiateMultipartUploadRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            Assert.False(TestConstants.RequestEC1.ContainsKey(EncryptionUtils.XAmzEncryptionContextCekAlg));
+        }
+
+        [Fact]
+        public void SetEncryptionContext_WithEmptyDictionary()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            
+            var emptyEncryptionContext = new Dictionary<string, string>();
+            
+            putObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            getObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            initiateMultipartUploadRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            
+            putObjectRequest.SetEncryptionContext(emptyEncryptionContext);
+            getObjectRequest.SetEncryptionContext(emptyEncryptionContext);
+            initiateMultipartUploadRequest.SetEncryptionContext(emptyEncryptionContext);
+            
+            var retrievedECForPut = EncryptionContextUtils.GetEncryptionContextFromRequest(putObjectRequest);
+            var retrievedECForGet = EncryptionContextUtils.GetEncryptionContextFromRequest(getObjectRequest);
+            var retrievedECForInitMPU = EncryptionContextUtils.GetEncryptionContextFromRequest(initiateMultipartUploadRequest);
+            
+            Assert.NotNull(retrievedECForPut);
+            Assert.Empty(retrievedECForPut);
+            
+            Assert.Equal(retrievedECForPut, retrievedECForGet);
+            Assert.Equal(retrievedECForGet, retrievedECForInitMPU);
+        }
+
+        [Fact]
+        public void SetEncryptionContext_WithDifferentRequestTypes_WorksCorrectly()
+        {
+            var putRequest = new PutObjectRequest();
+            var getRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            var context1 = new Dictionary<string, string> { { "key1", "value1" } };
+            var context2 = new Dictionary<string, string> { { "key2", "value2" } };
+            var context3 = new Dictionary<string, string> { { "key3", "value3" } };
+            
+            putRequest.SetEncryptionContext(context1);
+            getRequest.SetEncryptionContext(context2);
+            initiateMultipartUploadRequest.SetEncryptionContext(context3);
+            
+            var putResult = EncryptionContextUtils.GetEncryptionContextFromRequest(putRequest);
+            var getResult = EncryptionContextUtils.GetEncryptionContextFromRequest(getRequest);
+            var initMultipartResult = 
+                EncryptionContextUtils.GetEncryptionContextFromRequest(initiateMultipartUploadRequest);
+
+            Assert.True(putResult.ContainsKey("key1"));
+            Assert.False(putResult.ContainsKey("key2"));
+            Assert.False(putResult.ContainsKey("key3"));
+            Assert.False(getResult.ContainsKey("key1"));
+            Assert.True(getResult.ContainsKey("key2"));
+            Assert.False(getResult.ContainsKey("key3"));
+            Assert.False(initMultipartResult.ContainsKey("key1"));
+            Assert.False(initMultipartResult.ContainsKey("key2"));
+            Assert.True(initMultipartResult.ContainsKey("key3"));
+            
+            Assert.Equal("value1", putResult["key1"]);
+            Assert.Equal("value2", getResult["key2"]);
+            Assert.Equal("value3", initMultipartResult["key3"]);
+        }
+    }
+}
diff --git a/test/UnitTests/Util/EncryptionContextUtilsTests.cs b/test/UnitTests/Util/EncryptionContextUtilsTests.cs
new file mode 100644
index 0000000..0e9acf9
--- /dev/null
+++ b/test/UnitTests/Util/EncryptionContextUtilsTests.cs
@@ -0,0 +1,190 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+using System.Collections.Generic;
+using Amazon.Extensions.S3.Encryption.Extensions;
+using Amazon.Extensions.S3.Encryption.Tests.Common;
+using Amazon.Extensions.S3.Encryption.Util;
+using Amazon.S3.Model;
+using Xunit;
+
+namespace Amazon.Extensions.S3.Encryption.UnitTests.Util
+{
+    public class EncryptionContextUtilsTests
+    {
+        [Fact]
+        public void ValidateNoEncryptionContextForNonKMS_ThrowsWhenContextExists()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            
+            putObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            getObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            initiateMultipartUploadRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            
+            var mockExecutionContextPutObject = Utils.CreateMockExecutionContext(putObjectRequest);
+            var mockExecutionContextGetObject = Utils.CreateMockExecutionContext(getObjectRequest);
+            var mockExecutionContextInitMPU = Utils.CreateMockExecutionContext(initiateMultipartUploadRequest);
+            
+            var exceptionPutObject = Assert.Throws<System.ArgumentException>(() => 
+                EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(mockExecutionContextPutObject.Object));
+            var exceptionGetObject = Assert.Throws<System.ArgumentException>(() => 
+                EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(mockExecutionContextGetObject.Object));
+            var exceptionInitMPU = Assert.Throws<System.ArgumentException>(() => 
+                EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(mockExecutionContextInitMPU.Object));
+            
+            Assert.Contains("Encryption context is only supported for KMS encryption material from V2.", exceptionPutObject.Message);
+            Assert.Equal(exceptionPutObject.Message, exceptionGetObject.Message);
+            Assert.Equal(exceptionGetObject.Message, exceptionInitMPU.Message);
+        }
+        
+        [Fact]
+        public void ValidateNoEncryptionContextForNonKMS_DoesNotThrowWhenContextIsNull()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            
+            var mockExecutionContextPutObject = Utils.CreateMockExecutionContext(putObjectRequest);
+            var mockExecutionContextGetObject = Utils.CreateMockExecutionContext(getObjectRequest);
+            var mockExecutionContextInitMPU = Utils.CreateMockExecutionContext(initiateMultipartUploadRequest);
+
+            EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(mockExecutionContextPutObject.Object);
+            EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(mockExecutionContextGetObject.Object);
+            EncryptionContextUtils.ValidateNoEncryptionContextForNonKMS(mockExecutionContextInitMPU.Object);
+        }
+
+        [Fact]
+        public void GetEncryptionContextFromRequest_ReturnsECFromRequest()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            
+            putObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            getObjectRequest.SetEncryptionContext(TestConstants.RequestEC1);
+            initiateMultipartUploadRequest.SetEncryptionContext(TestConstants.RequestEC1);
+
+            var ecPutObject = EncryptionContextUtils.GetEncryptionContextFromRequest(putObjectRequest);
+            var ecGetObject = EncryptionContextUtils.GetEncryptionContextFromRequest(getObjectRequest);
+            var ecInitMPU = EncryptionContextUtils.GetEncryptionContextFromRequest(initiateMultipartUploadRequest);
+            
+            Assert.True(ecPutObject.ContainsKey(TestConstants.RequestEC1Key));
+            Assert.Equal(TestConstants.RequestEC1Value, ecPutObject[TestConstants.RequestEC1Key]);
+            Assert.Equal(ecPutObject, ecGetObject);
+            Assert.Equal(ecGetObject, ecInitMPU);
+        }
+        
+        [Fact]
+        public void GetEncryptionContextFromRequest_WhenSetNothingReturnsNull()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+
+            var exceptionPutObject = EncryptionContextUtils.GetEncryptionContextFromRequest(putObjectRequest);
+            var exceptionGetObject = EncryptionContextUtils.GetEncryptionContextFromRequest(getObjectRequest);
+            var exceptionInitMPU = EncryptionContextUtils.GetEncryptionContextFromRequest(initiateMultipartUploadRequest);
+            
+            Assert.Null(exceptionPutObject);
+            Assert.Null(exceptionGetObject);
+            Assert.Null(exceptionInitMPU);
+        }
+        
+        [Fact]
+        public void GetEncryptionContextFromRequest_WhenSetNullReturnsNull()
+        {
+            var putObjectRequest = new PutObjectRequest();
+            var getObjectRequest = new GetObjectRequest();
+            var initiateMultipartUploadRequest = new InitiateMultipartUploadRequest();
+            
+            putObjectRequest.SetEncryptionContext(null);
+            getObjectRequest.SetEncryptionContext(null);
+            initiateMultipartUploadRequest.SetEncryptionContext(null);
+
+            var exceptionPutObject = EncryptionContextUtils.GetEncryptionContextFromRequest(putObjectRequest);
+            var exceptionGetObject = EncryptionContextUtils.GetEncryptionContextFromRequest(getObjectRequest);
+            var exceptionInitMPU = EncryptionContextUtils.GetEncryptionContextFromRequest(initiateMultipartUploadRequest);
+            
+            Assert.Null(exceptionPutObject);
+            Assert.Null(exceptionGetObject);
+            Assert.Null(exceptionInitMPU);
+        }
+
+        [Fact]
+        public void ValidateEncryptionContext_DoesNotThrowWhenContextsExactMatch()
+        {
+            EncryptionContextUtils.ValidateEncryptionContext(TestConstants.RequestEC1, TestConstants.RequestEC1);
+        }
+        
+        [Fact]
+        public void ValidateEncryptionContext_ThrowsWhenCompleteMismatched()
+        {
+            var exception = Assert.Throws<AmazonS3EncryptionClientException>(() => 
+                EncryptionContextUtils.ValidateEncryptionContext(TestConstants.RequestEC1, TestConstants.RequestEC2));
+            
+            Assert.Contains("Provided encryption context does not match information retrieved from S3", exception.Message);
+        }
+
+        [Fact]
+        public void ValidateEncryptionContext_ThrowsWhenEffectiveHasMoreKeys()
+        {
+            var effectiveEC = new Dictionary<string, string> { { "key1", "value1" }, { "key2", "value2" } };
+            var metadataEC = new Dictionary<string, string> { { "key1", "value1" } };
+
+            var exception = Assert.Throws<AmazonS3EncryptionClientException>(() => 
+                EncryptionContextUtils.ValidateEncryptionContext(effectiveEC, metadataEC));
+            
+            Assert.Contains("Provided encryption context does not match information retrieved from S3", exception.Message);
+        }
+
+        [Fact]
+        public void ValidateEncryptionContext_ThrowsWhenMetadataHasMoreKeys()
+        {
+            var effectiveEC = new Dictionary<string, string> { { "key1", "value1" } };
+            var metadataEC = new Dictionary<string, string> { { "key1", "value1" }, { "key2", "value2" } };
+
+            var exception = Assert.Throws<AmazonS3EncryptionClientException>(() => 
+                EncryptionContextUtils.ValidateEncryptionContext(effectiveEC, metadataEC));
+            
+            Assert.Contains("Provided encryption context does not match information retrieved from S3", exception.Message);
+        }
+
+        [Fact]
+        public void ValidateEncryptionContext_ThrowsWhenValueMismatch()
+        {
+            var effectiveEC = new Dictionary<string, string> { { "key1", "value1" } };
+            var metadataEC = new Dictionary<string, string> { { "key1", "wrongvalue" } };
+
+            var exception = Assert.Throws<AmazonS3EncryptionClientException>(() => 
+                EncryptionContextUtils.ValidateEncryptionContext(effectiveEC, metadataEC));
+            
+            Assert.Contains("Provided encryption context does not match information retrieved from S3", exception.Message);
+        }
+        
+        [Fact]
+        public void ValidateEncryptionContext_ThrowsWhenKeyMismatch()
+        {
+            var effectiveEC = new Dictionary<string, string> { { "key1", "value1" } };
+            var metadataEC = new Dictionary<string, string> { { "key2", "value1" } };
+
+            var exception = Assert.Throws<AmazonS3EncryptionClientException>(() => 
+                EncryptionContextUtils.ValidateEncryptionContext(effectiveEC, metadataEC));
+            
+            Assert.Contains("Provided encryption context does not match information retrieved from S3", exception.Message);
+        }
+    }
+}
\ No newline at end of file
diff --git a/test/UnitTests/Utils.cs b/test/UnitTests/Utils.cs
index 11a4c92..fba3b0f 100644
--- a/test/UnitTests/Utils.cs
+++ b/test/UnitTests/Utils.cs
@@ -15,6 +15,8 @@
 
 using System;
 using System.Reflection;
+using Amazon.Runtime;
+using Moq;
 
 namespace Amazon.Extensions.S3.Encryption.UnitTests
 {
@@ -72,5 +74,16 @@ namespace Amazon.Extensions.S3.Encryption.UnitTests
                 throw e.InnerException;
             }
         }
+        
+        public static Mock<IExecutionContext> CreateMockExecutionContext(AmazonWebServiceRequest request)
+        {
+            var mockRequestContext = new Mock<IRequestContext>();
+            mockRequestContext.Setup(x => x.OriginalRequest).Returns(request);
+            
+            var mockExecutionContext = new Mock<IExecutionContext>();
+            mockExecutionContext.Setup(x => x.RequestContext).Returns(mockRequestContext.Object);
+            
+            return mockExecutionContext;
+        }
     }
 }
